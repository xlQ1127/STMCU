; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections -c --asm --interleave -o.\flash\obj\mpu6050.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\mpu6050.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\User\usb_virture_com -I..\..\User -I..\..\User\bsp -I..\..\User\Driver\IIC -I..\..\User\Driver\LED -I..\..\User\Driver\TIM -I..\..\User\Driver\SPI -I..\..\User\Driver\ADC -I..\..\User\Driver\Delay -I..\..\User\Driver\UART -I..\..\User\Driver\MOTOR -I..\..\User\Driver\PWM_IN -I..\..\User\Driver\EEPROM -I..\..\User\Modules\Modules_mpu6050 -I..\..\User\Modules\Modules_nrf24L01 -I..\..\User\Modules\Modules_hmc5883 -I..\..\User\Algorithm\Algorithm_filter -I..\..\User\Algorithm\Algorithm_math -I..\..\User\Algorithm\Algorithm_sqLite -I..\..\User\Algorithm\Algorithm_quaternion -I..\..\User\Function\MultiRotor_rc -I..\..\User\Function\MultiRotor_app -I..\..\User\Function\MultiRotor_ahrs -I..\..\User\Function\MultiRotor_radio -I..\..\User\Function\MultiRotor_control -I..\..\User\Modules\Modules_oled -I..\..\User\Driver\STMFLASH -I.\RTE\_Flash -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\mpu6050.crf ..\..\User\Modules\Modules_mpu6050\mpu6050.c]
                          THUMB

                          AREA ||i.Gyro_Caloffest||, CODE, READONLY, ALIGN=2

                  Gyro_Caloffest PROC
;;;136    /*====================================================================================================*/
;;;137    void Gyro_Caloffest(s32 x,s32 y,s32 z,u16 amount)
000000  b530              PUSH     {r4,r5,lr}
;;;138    {
;;;139         sensor.gyro.quiet.x = x/amount;
000002  fb90f4f3          SDIV     r4,r0,r3
000006  b225              SXTH     r5,r4
000008  4c07              LDR      r4,|L1.40|
00000a  f8a45054          STRH     r5,[r4,#0x54]
;;;140    	 sensor.gyro.quiet.y = y/amount;
00000e  fb91f4f3          SDIV     r4,r1,r3
000012  b225              SXTH     r5,r4
000014  4c04              LDR      r4,|L1.40|
000016  f8a45056          STRH     r5,[r4,#0x56]
;;;141    	 sensor.gyro.quiet.z = z/amount;
00001a  fb92f4f3          SDIV     r4,r2,r3
00001e  b225              SXTH     r5,r4
000020  4c01              LDR      r4,|L1.40|
000022  f8a45058          STRH     r5,[r4,#0x58]
;;;142    }
000026  bd30              POP      {r4,r5,pc}
;;;143    
                          ENDP

                  |L1.40|
                          DCD      sensor

                          AREA ||i.Gyro_OFFSET||, CODE, READONLY, ALIGN=2

                  Gyro_OFFSET PROC
;;;154    //此循环须确保四轴处于完全静止状态    标志位只在函数内使用
;;;155    void Gyro_OFFSET(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;156    {
000004  b086              SUB      sp,sp,#0x18
;;;157    	static u8 over_flag=0;                           //【u8  over_flag 】
;;;158    	u8  i,cnt_g = 0;                                 //【u8  i  , cnt_g】
000006  f04f0800          MOV      r8,#0
;;;159    	s32 Integral[3] = {0,0,0};                       //【s32 Integral[3]】
00000a  2000              MOVS     r0,#0
00000c  9003              STR      r0,[sp,#0xc]
00000e  9004              STR      r0,[sp,#0x10]
000010  9005              STR      r0,[sp,#0x14]
;;;160    	s32 tempg[3]={0,0,0};                            //【s32   tempg[3] 】
000012  9000              STR      r0,[sp,#0]
000014  9001              STR      r0,[sp,#4]
000016  9002              STR      r0,[sp,#8]
;;;161    	s16 gx_last=0,gy_last=0,gz_last=0;               //【s16 gx_last=0  , gy_last=0 , gz_last=0】
000018  2500              MOVS     r5,#0
00001a  2600              MOVS     r6,#0
00001c  2700              MOVS     r7,#0
;;;162    
;;;163    	while(!over_flag)	                   
00001e  e078              B        |L2.274|
                  |L2.32|
;;;164    	{
;;;165    		if(cnt_g < 50)
000020  f1b80f32          CMP      r8,#0x32
000024  da51              BGE      |L2.202|
;;;166    		{
;;;167    			MPU6050_Dataanl();                //陀螺零偏的初始值问题   
000026  f7fffffe          BL       MPU6050_Dataanl
;;;168    
;;;169    			tempg[0] += sensor.gyro.origin.x; //此处使用的是陀螺初始值 所以没必要考虑零偏初值的问题
00002a  493d              LDR      r1,|L2.288|
00002c  f9b11034          LDRSH    r1,[r1,#0x34]  ; sensor
000030  9800              LDR      r0,[sp,#0]
000032  4408              ADD      r0,r0,r1
000034  9000              STR      r0,[sp,#0]
;;;170    			tempg[1] += sensor.gyro.origin.y;
000036  483a              LDR      r0,|L2.288|
000038  f9b00036          LDRSH    r0,[r0,#0x36]
00003c  9901              LDR      r1,[sp,#4]
00003e  4408              ADD      r0,r0,r1
000040  9001              STR      r0,[sp,#4]
;;;171    			tempg[2] += sensor.gyro.origin.z;
000042  4837              LDR      r0,|L2.288|
000044  f9b00038          LDRSH    r0,[r0,#0x38]
000048  9902              LDR      r1,[sp,#8]
00004a  4408              ADD      r0,r0,r1
00004c  9002              STR      r0,[sp,#8]
;;;172                
;;;173                //absu16( Math_X )  (Math_X<0? -Math_X:Math_X)
;;;174    			Integral[0] += absu16(gx_last - sensor.gyro.origin.x);  // 前次采样值 减 本次采样值  每次都取正
00004e  4834              LDR      r0,|L2.288|
000050  f9b00034          LDRSH    r0,[r0,#0x34]  ; sensor
000054  9903              LDR      r1,[sp,#0xc]
000056  1a28              SUBS     r0,r5,r0
000058  d505              BPL      |L2.102|
00005a  4831              LDR      r0,|L2.288|
00005c  f9b00034          LDRSH    r0,[r0,#0x34]  ; sensor
000060  426a              RSBS     r2,r5,#0
000062  1a10              SUBS     r0,r2,r0
000064  e003              B        |L2.110|
                  |L2.102|
000066  482e              LDR      r0,|L2.288|
000068  f9b00034          LDRSH    r0,[r0,#0x34]  ; sensor
00006c  1a28              SUBS     r0,r5,r0
                  |L2.110|
00006e  4408              ADD      r0,r0,r1
000070  9003              STR      r0,[sp,#0xc]
;;;175    			Integral[1] += absu16(gy_last - sensor.gyro.origin.y);    
000072  482b              LDR      r0,|L2.288|
000074  f9b00036          LDRSH    r0,[r0,#0x36]
000078  9904              LDR      r1,[sp,#0x10]
00007a  1a30              SUBS     r0,r6,r0
00007c  d505              BPL      |L2.138|
00007e  4828              LDR      r0,|L2.288|
000080  f9b00036          LDRSH    r0,[r0,#0x36]
000084  4272              RSBS     r2,r6,#0
000086  1a10              SUBS     r0,r2,r0
000088  e003              B        |L2.146|
                  |L2.138|
00008a  4825              LDR      r0,|L2.288|
00008c  f9b00036          LDRSH    r0,[r0,#0x36]
000090  1a30              SUBS     r0,r6,r0
                  |L2.146|
000092  4408              ADD      r0,r0,r1
000094  9004              STR      r0,[sp,#0x10]
;;;176    			Integral[2] += absu16(gz_last - sensor.gyro.origin.z);
000096  4822              LDR      r0,|L2.288|
000098  f9b00038          LDRSH    r0,[r0,#0x38]
00009c  9905              LDR      r1,[sp,#0x14]
00009e  1a38              SUBS     r0,r7,r0
0000a0  d505              BPL      |L2.174|
0000a2  481f              LDR      r0,|L2.288|
0000a4  f9b00038          LDRSH    r0,[r0,#0x38]
0000a8  427a              RSBS     r2,r7,#0
0000aa  1a10              SUBS     r0,r2,r0
0000ac  e003              B        |L2.182|
                  |L2.174|
0000ae  481c              LDR      r0,|L2.288|
0000b0  f9b00038          LDRSH    r0,[r0,#0x38]
0000b4  1a38              SUBS     r0,r7,r0
                  |L2.182|
0000b6  4408              ADD      r0,r0,r1
0000b8  9005              STR      r0,[sp,#0x14]
;;;177    
;;;178    			gx_last = sensor.gyro.origin.x;
0000ba  4819              LDR      r0,|L2.288|
0000bc  f9b05034          LDRSH    r5,[r0,#0x34]  ; sensor
;;;179    			gy_last = sensor.gyro.origin.y;                  
0000c0  f9b06036          LDRSH    r6,[r0,#0x36]
;;;180    			gz_last = sensor.gyro.origin.z;
0000c4  f9b07038          LDRSH    r7,[r0,#0x38]
0000c8  e01f              B        |L2.266|
                  |L2.202|
;;;181    		}
;;;182    		else{
;;;183    			// 未校准成功  GYRO_GATHER   100 如果两次采样值差值过大则静态采样失败   此处采样静态机体陀螺仪数据 两次偏差不可能过大
;;;184    			if(Integral[0]>=GYRO_GATHER || Integral[1]>=GYRO_GATHER || Integral[2]>= GYRO_GATHER){
0000ca  9803              LDR      r0,[sp,#0xc]
0000cc  2864              CMP      r0,#0x64
0000ce  da05              BGE      |L2.220|
0000d0  9804              LDR      r0,[sp,#0x10]
0000d2  2864              CMP      r0,#0x64
0000d4  da02              BGE      |L2.220|
0000d6  9805              LDR      r0,[sp,#0x14]
0000d8  2864              CMP      r0,#0x64
0000da  db0e              BLT      |L2.250|
                  |L2.220|
;;;185    				cnt_g = 0;
0000dc  f04f0800          MOV      r8,#0
;;;186    				for(i=0;i<3;i++){
0000e0  2400              MOVS     r4,#0
0000e2  e007              B        |L2.244|
                  |L2.228|
;;;187    				tempg[i]=Integral[i]=0;  //清空 累加数据
0000e4  2000              MOVS     r0,#0
0000e6  a903              ADD      r1,sp,#0xc
0000e8  f8410024          STR      r0,[r1,r4,LSL #2]
0000ec  f84d0024          STR      r0,[sp,r4,LSL #2]
0000f0  1c60              ADDS     r0,r4,#1              ;186
0000f2  b2c4              UXTB     r4,r0                 ;186
                  |L2.244|
0000f4  2c03              CMP      r4,#3                 ;186
0000f6  dbf5              BLT      |L2.228|
0000f8  e007              B        |L2.266|
                  |L2.250|
;;;188    				}
;;;189    			}
;;;190    			// 校准成功 
;;;191    			else{				
;;;192    				   Gyro_Caloffest(tempg[0],tempg[1],tempg[2],50); //计算陀螺仪零偏值
0000fa  2332              MOVS     r3,#0x32
0000fc  e89d0007          LDM      sp,{r0-r2}
000100  f7fffffe          BL       Gyro_Caloffest
;;;193    				   over_flag = 1;
000104  2001              MOVS     r0,#1
000106  4907              LDR      r1,|L2.292|
000108  7008              STRB     r0,[r1,#0]
                  |L2.266|
;;;194    			}
;;;195    		}
;;;196    		cnt_g++;
00010a  f1080001          ADD      r0,r8,#1
00010e  f00008ff          AND      r8,r0,#0xff
                  |L2.274|
000112  4804              LDR      r0,|L2.292|
000114  7800              LDRB     r0,[r0,#0]            ;163  ; over_flag
000116  2800              CMP      r0,#0                 ;163
000118  d082              BEQ      |L2.32|
;;;197    	}
;;;198    }
00011a  b006              ADD      sp,sp,#0x18
00011c  e8bd81f0          POP      {r4-r8,pc}
;;;199    
                          ENDP

                  |L2.288|
                          DCD      sensor
                  |L2.292|
                          DCD      over_flag

                          AREA ||i.InitMPU6050||, CODE, READONLY, ALIGN=1

                  InitMPU6050 PROC
;;;36     /*====================================================================================================*/
;;;37     u8 InitMPU6050(void)
000000  b510              PUSH     {r4,lr}
;;;38     {
;;;39     	u8 ack;
;;;40     	//MPU6050做从机设备有八位地址  高七位0X68存储在Who am I中 低一位由AD0决定
;;;41     	ack = Single_Read(MPU6050_ADDRESS, WHO_AM_I);                      //检查MPU6050是否连接汉
000002  2175              MOVS     r1,#0x75
000004  20d0              MOVS     r0,#0xd0
000006  f7fffffe          BL       Single_Read
00000a  4604              MOV      r4,r0
;;;42     	if (!ack)    //正常ack=0X68真    !ack=0假   执行初始化
00000c  b90c              CBNZ     r4,|L3.18|
;;;43         return FALSE;
00000e  2000              MOVS     r0,#0
                  |L3.16|
;;;44     	
;;;45     	Single_Write(MPU6050_ADDRESS, PWR_MGMT_1, 0x00);  	               //解除休眠状态
;;;46         //SMPLRT_DIV	0x19	//陀螺仪采样率，典型值：0x07(125Hz)          //8ms采集一次
;;;47     	Single_Write(MPU6050_ADDRESS, SMPLRT_DIV, 0x07);     
;;;48     	Single_Write(MPU6050_ADDRESS, CONFIGL, MPU6050_DLPF);              //低通滤波
;;;49     	Single_Write(MPU6050_ADDRESS, GYRO_CONFIG, MPU6050_GYRO_FS_1000);  //陀螺仪量程 +-1000
;;;50     	Single_Write(MPU6050_ADDRESS, ACCEL_CONFIG, MPU6050_ACCEL_FS_4);   //加速度量程 +-4G
;;;51     	return TRUE;
;;;52     }
000010  bd10              POP      {r4,pc}
                  |L3.18|
000012  2200              MOVS     r2,#0                 ;45
000014  216b              MOVS     r1,#0x6b              ;45
000016  20d0              MOVS     r0,#0xd0              ;45
000018  f7fffffe          BL       Single_Write
00001c  2207              MOVS     r2,#7                 ;47
00001e  2119              MOVS     r1,#0x19              ;47
000020  20d0              MOVS     r0,#0xd0              ;47
000022  f7fffffe          BL       Single_Write
000026  2203              MOVS     r2,#3                 ;48
000028  211a              MOVS     r1,#0x1a              ;48
00002a  20d0              MOVS     r0,#0xd0              ;48
00002c  f7fffffe          BL       Single_Write
000030  2210              MOVS     r2,#0x10              ;49
000032  211b              MOVS     r1,#0x1b              ;49
000034  20d0              MOVS     r0,#0xd0              ;49
000036  f7fffffe          BL       Single_Write
00003a  2209              MOVS     r2,#9                 ;50
00003c  211c              MOVS     r1,#0x1c              ;50
00003e  20d0              MOVS     r0,#0xd0              ;50
000040  f7fffffe          BL       Single_Write
000044  2001              MOVS     r0,#1                 ;51
000046  e7e3              B        |L3.16|
;;;53     
                          ENDP


                          AREA ||i.MPU6050_Dataanl||, CODE, READONLY, ALIGN=2

                  MPU6050_Dataanl PROC
;;;76     *******************************************************************************/
;;;77     void MPU6050_Dataanl(void)       //MPU6050输出数据为16位
000000  b510              PUSH     {r4,lr}
;;;78     {
;;;79     	MPU6050_Read();
000002  f7fffffe          BL       MPU6050_Read
;;;80     	                             //读到的数据进行合并减零偏
;;;81     	sensor.acc.origin.x = ((((int16_t)mpu6050_buffer[0]) << 8) | mpu6050_buffer[1]) - sensor.acc.quiet.x; // 【加速度计数据】
000006  485c              LDR      r0,|L4.376|
000008  7840              LDRB     r0,[r0,#1]  ; mpu6050_buffer
00000a  495b              LDR      r1,|L4.376|
00000c  7809              LDRB     r1,[r1,#0]  ; mpu6050_buffer
00000e  ea402001          ORR      r0,r0,r1,LSL #8
000012  495a              LDR      r1,|L4.380|
000014  8c09              LDRH     r1,[r1,#0x20]  ; sensor
000016  1a40              SUBS     r0,r0,r1
000018  b200              SXTH     r0,r0
00001a  4958              LDR      r1,|L4.380|
00001c  8008              STRH     r0,[r1,#0]
;;;82     	sensor.acc.origin.y = ((((int16_t)mpu6050_buffer[2]) << 8) | mpu6050_buffer[3]) - sensor.acc.quiet.y;
00001e  4856              LDR      r0,|L4.376|
000020  78c0              LDRB     r0,[r0,#3]  ; mpu6050_buffer
000022  4955              LDR      r1,|L4.376|
000024  7889              LDRB     r1,[r1,#2]  ; mpu6050_buffer
000026  ea402101          ORR      r1,r0,r1,LSL #8
00002a  4854              LDR      r0,|L4.380|
00002c  8c40              LDRH     r0,[r0,#0x22]
00002e  1a08              SUBS     r0,r1,r0
000030  b200              SXTH     r0,r0
000032  4952              LDR      r1,|L4.380|
000034  8048              STRH     r0,[r1,#2]
;;;83     	sensor.acc.origin.z = ((((int16_t)mpu6050_buffer[4]) << 8) | mpu6050_buffer[5]);                      //Z轴加速度计未减零偏
000036  4850              LDR      r0,|L4.376|
000038  7940              LDRB     r0,[r0,#5]  ; mpu6050_buffer
00003a  494f              LDR      r1,|L4.376|
00003c  7909              LDRB     r1,[r1,#4]  ; mpu6050_buffer
00003e  ea402001          ORR      r0,r0,r1,LSL #8
000042  b200              SXTH     r0,r0
000044  494d              LDR      r1,|L4.380|
000046  8088              STRH     r0,[r1,#4]
;;;84     
;;;85     	sensor.gyro.origin.x = ((((int16_t)mpu6050_buffer[8]) << 8) | mpu6050_buffer[9]);                     // 【陀螺仪数据】
000048  484b              LDR      r0,|L4.376|
00004a  7a40              LDRB     r0,[r0,#9]  ; mpu6050_buffer
00004c  494a              LDR      r1,|L4.376|
00004e  7a09              LDRB     r1,[r1,#8]  ; mpu6050_buffer
000050  ea402001          ORR      r0,r0,r1,LSL #8
000054  b200              SXTH     r0,r0
000056  4949              LDR      r1,|L4.380|
000058  8688              STRH     r0,[r1,#0x34]
;;;86     	sensor.gyro.origin.y = ((((int16_t)mpu6050_buffer[10]) << 8)| mpu6050_buffer[11]);
00005a  4847              LDR      r0,|L4.376|
00005c  7ac0              LDRB     r0,[r0,#0xb]  ; mpu6050_buffer
00005e  4946              LDR      r1,|L4.376|
000060  7a89              LDRB     r1,[r1,#0xa]  ; mpu6050_buffer
000062  ea402001          ORR      r0,r0,r1,LSL #8
000066  b201              SXTH     r1,r0
000068  4844              LDR      r0,|L4.380|
00006a  86c1              STRH     r1,[r0,#0x36]
;;;87     	sensor.gyro.origin.z = ((((int16_t)mpu6050_buffer[12]) << 8)| mpu6050_buffer[13]);
00006c  4842              LDR      r0,|L4.376|
00006e  7b40              LDRB     r0,[r0,#0xd]  ; mpu6050_buffer
000070  4941              LDR      r1,|L4.376|
000072  7b09              LDRB     r1,[r1,#0xc]  ; mpu6050_buffer
000074  ea402001          ORR      r0,r0,r1,LSL #8
000078  b201              SXTH     r1,r0
00007a  4840              LDR      r0,|L4.380|
00007c  8701              STRH     r1,[r0,#0x38]
;;;88         //陀螺零偏分开减的好处 因为 下边陀螺零偏计算函数要用到陀螺初始值
;;;89     	sensor.gyro.radian.x = sensor.gyro.origin.x - sensor.gyro.quiet.x;                                    // 【陀螺仪数据减零偏】
00007e  4601              MOV      r1,r0
000080  f9b12034          LDRSH    r2,[r1,#0x34]  ; sensor
000084  f9b11054          LDRSH    r1,[r1,#0x54]
000088  1a50              SUBS     r0,r2,r1
00008a  f7fffffe          BL       __aeabi_i2f
00008e  493b              LDR      r1,|L4.380|
000090  65c8              STR      r0,[r1,#0x5c]
;;;90     	sensor.gyro.radian.y = sensor.gyro.origin.y - sensor.gyro.quiet.y;
000092  f9b12036          LDRSH    r2,[r1,#0x36]
000096  f9b11056          LDRSH    r1,[r1,#0x56]
00009a  1a50              SUBS     r0,r2,r1
00009c  f7fffffe          BL       __aeabi_i2f
0000a0  4601              MOV      r1,r0
0000a2  4836              LDR      r0,|L4.380|
0000a4  6601              STR      r1,[r0,#0x60]
;;;91     	sensor.gyro.radian.z = sensor.gyro.origin.z - sensor.gyro.quiet.z;
0000a6  4601              MOV      r1,r0
0000a8  f9b12038          LDRSH    r2,[r1,#0x38]
0000ac  f9b11058          LDRSH    r1,[r1,#0x58]
0000b0  1a50              SUBS     r0,r2,r1
0000b2  f7fffffe          BL       __aeabi_i2f
0000b6  4601              MOV      r1,r0
0000b8  4830              LDR      r0,|L4.380|
0000ba  6641              STR      r1,[r0,#0x64]
;;;92     
;;;93     //    	The calibration  of  acc                      //【加速度计零偏计算】
;;;94     //      此处加速度计是如何实现累加计算的
;;;95     //      此函数在姿态结算函数中调用 每中断一次执行一次
;;;96     //      通过中断轮询加静态局部变量实现累加
;;;97     //*****************************************************************************//	
;;;98     	 if(flag.calibratingA)                            //【标志位】 如果加速度零偏计算没有完成  flag.calibratingA在rc.c中定义
0000bc  4830              LDR      r0,|L4.384|
0000be  7980              LDRB     r0,[r0,#6]  ; flag
0000c0  2800              CMP      r0,#0
0000c2  d057              BEQ      |L4.372|
;;;99     	 {
;;;100    		 static int32_t	tempax=0,tempay=0,tempaz=0;   //则计算加速度零偏
;;;101    		 static uint8_t cnt_a=0;
;;;102    		 if(cnt_a==0)                                 //首次清零
0000c4  482f              LDR      r0,|L4.388|
0000c6  7800              LDRB     r0,[r0,#0]  ; cnt_a
0000c8  b980              CBNZ     r0,|L4.236|
;;;103    		 {
;;;104    				sensor.acc.quiet.x = 0;
0000ca  2000              MOVS     r0,#0
0000cc  492b              LDR      r1,|L4.380|
0000ce  8408              STRH     r0,[r1,#0x20]
;;;105    				sensor.acc.quiet.y = 0;
0000d0  2100              MOVS     r1,#0
0000d2  482a              LDR      r0,|L4.380|
0000d4  8441              STRH     r1,[r0,#0x22]
;;;106    				sensor.acc.quiet.z = 0;
0000d6  8481              STRH     r1,[r0,#0x24]
;;;107    				tempax = 0;
0000d8  2000              MOVS     r0,#0
0000da  492b              LDR      r1,|L4.392|
0000dc  6008              STR      r0,[r1,#0]  ; tempax
;;;108    				tempay = 0;
0000de  492b              LDR      r1,|L4.396|
0000e0  6008              STR      r0,[r1,#0]  ; tempay
;;;109    				tempaz = 0;
0000e2  492b              LDR      r1,|L4.400|
0000e4  6008              STR      r0,[r1,#0]  ; tempaz
;;;110    				cnt_a = 1;
0000e6  2001              MOVS     r0,#1
0000e8  4926              LDR      r1,|L4.388|
0000ea  7008              STRB     r0,[r1,#0]
                  |L4.236|
;;;111    		 }
;;;112    				tempax+= sensor.acc.origin.x;
0000ec  4823              LDR      r0,|L4.380|
0000ee  f9b00000          LDRSH    r0,[r0,#0]  ; sensor
0000f2  4925              LDR      r1,|L4.392|
0000f4  6809              LDR      r1,[r1,#0]  ; tempax
0000f6  4408              ADD      r0,r0,r1
0000f8  4923              LDR      r1,|L4.392|
0000fa  6008              STR      r0,[r1,#0]  ; tempax
;;;113    				tempay+= sensor.acc.origin.y;
0000fc  481f              LDR      r0,|L4.380|
0000fe  f9b00002          LDRSH    r0,[r0,#2]  ; sensor
000102  4922              LDR      r1,|L4.396|
000104  6809              LDR      r1,[r1,#0]  ; tempay
000106  4408              ADD      r0,r0,r1
000108  4920              LDR      r1,|L4.396|
00010a  6008              STR      r0,[r1,#0]  ; tempay
;;;114    				tempaz+= sensor.acc.origin.z;
00010c  481b              LDR      r0,|L4.380|
00010e  f9b00004          LDRSH    r0,[r0,#4]  ; sensor
000112  491f              LDR      r1,|L4.400|
000114  6809              LDR      r1,[r1,#0]  ; tempaz
000116  4408              ADD      r0,r0,r1
000118  491d              LDR      r1,|L4.400|
00011a  6008              STR      r0,[r1,#0]  ; tempaz
;;;115    				if(cnt_a==200)                          //累加200次求平均值
00011c  4819              LDR      r0,|L4.388|
00011e  7800              LDRB     r0,[r0,#0]  ; cnt_a
000120  28c8              CMP      r0,#0xc8
000122  d122              BNE      |L4.362|
;;;116    				{
;;;117    					sensor.acc.quiet.x = tempax/cnt_a;
000124  4818              LDR      r0,|L4.392|
000126  6800              LDR      r0,[r0,#0]  ; tempax
000128  4916              LDR      r1,|L4.388|
00012a  7809              LDRB     r1,[r1,#0]  ; cnt_a
00012c  fb90f0f1          SDIV     r0,r0,r1
000130  b200              SXTH     r0,r0
000132  4912              LDR      r1,|L4.380|
000134  8408              STRH     r0,[r1,#0x20]
;;;118    					sensor.acc.quiet.y = tempay/cnt_a;
000136  4815              LDR      r0,|L4.396|
000138  6800              LDR      r0,[r0,#0]  ; tempay
00013a  4912              LDR      r1,|L4.388|
00013c  7809              LDRB     r1,[r1,#0]  ; cnt_a
00013e  fb90f0f1          SDIV     r0,r0,r1
000142  b201              SXTH     r1,r0
000144  480d              LDR      r0,|L4.380|
000146  8441              STRH     r1,[r0,#0x22]
;;;119    					sensor.acc.quiet.z = tempaz/cnt_a;
000148  4811              LDR      r0,|L4.400|
00014a  6800              LDR      r0,[r0,#0]  ; tempaz
00014c  490d              LDR      r1,|L4.388|
00014e  7809              LDRB     r1,[r1,#0]  ; cnt_a
000150  fb90f0f1          SDIV     r0,r0,r1
000154  b201              SXTH     r1,r0
000156  4809              LDR      r0,|L4.380|
000158  8481              STRH     r1,[r0,#0x24]
;;;120    					cnt_a = 0;
00015a  2000              MOVS     r0,#0
00015c  4909              LDR      r1,|L4.388|
00015e  7008              STRB     r0,[r1,#0]
;;;121    					flag.calibratingA = 0;
000160  4907              LDR      r1,|L4.384|
000162  7188              STRB     r0,[r1,#6]
;;;122    					EE_SAVE_ACC_OFFSET();               //把计算的加速度零偏值保存在EEPROM中
000164  f7fffffe          BL       EE_SAVE_ACC_OFFSET
                  |L4.360|
;;;123    					return;
;;;124    				}
;;;125    				cnt_a++;		
;;;126    			}	
;;;127    }
000168  bd10              POP      {r4,pc}
                  |L4.362|
00016a  4806              LDR      r0,|L4.388|
00016c  7800              LDRB     r0,[r0,#0]            ;125  ; cnt_a
00016e  1c40              ADDS     r0,r0,#1              ;125
000170  4904              LDR      r1,|L4.388|
000172  7008              STRB     r0,[r1,#0]            ;125
                  |L4.372|
000174  bf00              NOP      
000176  e7f7              B        |L4.360|
;;;128    /*====================================================================================================*/
                          ENDP

                  |L4.376|
                          DCD      mpu6050_buffer
                  |L4.380|
                          DCD      sensor
                  |L4.384|
                          DCD      flag
                  |L4.388|
                          DCD      cnt_a
                  |L4.392|
                          DCD      tempax
                  |L4.396|
                          DCD      tempay
                  |L4.400|
                          DCD      tempaz

                          AREA ||i.MPU6050_Read||, CODE, READONLY, ALIGN=2

                  MPU6050_Read PROC
;;;56     //******************************************************************************
;;;57     void MPU6050_Read(void)
000000  b510              PUSH     {r4,lr}
;;;58     {
;;;59     	mpu6050_buffer[0]=Single_Read(MPU6050_ADDRESS, 0x3B);
000002  213b              MOVS     r1,#0x3b
000004  20d0              MOVS     r0,#0xd0
000006  f7fffffe          BL       Single_Read
00000a  4922              LDR      r1,|L5.148|
00000c  7008              STRB     r0,[r1,#0]
;;;60     	mpu6050_buffer[1]=Single_Read(MPU6050_ADDRESS, 0x3C);
00000e  213c              MOVS     r1,#0x3c
000010  20d0              MOVS     r0,#0xd0
000012  f7fffffe          BL       Single_Read
000016  491f              LDR      r1,|L5.148|
000018  7048              STRB     r0,[r1,#1]
;;;61     	mpu6050_buffer[2]=Single_Read(MPU6050_ADDRESS, 0x3D);
00001a  213d              MOVS     r1,#0x3d
00001c  20d0              MOVS     r0,#0xd0
00001e  f7fffffe          BL       Single_Read
000022  491c              LDR      r1,|L5.148|
000024  7088              STRB     r0,[r1,#2]
;;;62     	mpu6050_buffer[3]=Single_Read(MPU6050_ADDRESS, 0x3E);
000026  213e              MOVS     r1,#0x3e
000028  20d0              MOVS     r0,#0xd0
00002a  f7fffffe          BL       Single_Read
00002e  4919              LDR      r1,|L5.148|
000030  70c8              STRB     r0,[r1,#3]
;;;63     	mpu6050_buffer[4]=Single_Read(MPU6050_ADDRESS, 0x3F);
000032  213f              MOVS     r1,#0x3f
000034  20d0              MOVS     r0,#0xd0
000036  f7fffffe          BL       Single_Read
00003a  4916              LDR      r1,|L5.148|
00003c  7108              STRB     r0,[r1,#4]
;;;64     	mpu6050_buffer[5]=Single_Read(MPU6050_ADDRESS, 0x40);
00003e  2140              MOVS     r1,#0x40
000040  20d0              MOVS     r0,#0xd0
000042  f7fffffe          BL       Single_Read
000046  4913              LDR      r1,|L5.148|
000048  7148              STRB     r0,[r1,#5]
;;;65     	mpu6050_buffer[8]=Single_Read(MPU6050_ADDRESS, 0x43);
00004a  2143              MOVS     r1,#0x43
00004c  20d0              MOVS     r0,#0xd0
00004e  f7fffffe          BL       Single_Read
000052  4910              LDR      r1,|L5.148|
000054  7208              STRB     r0,[r1,#8]
;;;66     	mpu6050_buffer[9]=Single_Read(MPU6050_ADDRESS, 0x44);
000056  2144              MOVS     r1,#0x44
000058  20d0              MOVS     r0,#0xd0
00005a  f7fffffe          BL       Single_Read
00005e  490d              LDR      r1,|L5.148|
000060  7248              STRB     r0,[r1,#9]
;;;67     	mpu6050_buffer[10]=Single_Read(MPU6050_ADDRESS, 0x45);
000062  2145              MOVS     r1,#0x45
000064  20d0              MOVS     r0,#0xd0
000066  f7fffffe          BL       Single_Read
00006a  490a              LDR      r1,|L5.148|
00006c  7288              STRB     r0,[r1,#0xa]
;;;68     	mpu6050_buffer[11]=Single_Read(MPU6050_ADDRESS, 0x46);
00006e  2146              MOVS     r1,#0x46
000070  20d0              MOVS     r0,#0xd0
000072  f7fffffe          BL       Single_Read
000076  4907              LDR      r1,|L5.148|
000078  72c8              STRB     r0,[r1,#0xb]
;;;69     	mpu6050_buffer[12]=Single_Read(MPU6050_ADDRESS, 0x47);
00007a  2147              MOVS     r1,#0x47
00007c  20d0              MOVS     r0,#0xd0
00007e  f7fffffe          BL       Single_Read
000082  4904              LDR      r1,|L5.148|
000084  7308              STRB     r0,[r1,#0xc]
;;;70     	mpu6050_buffer[13]=Single_Read(MPU6050_ADDRESS, 0x48);
000086  2148              MOVS     r1,#0x48
000088  20d0              MOVS     r0,#0xd0
00008a  f7fffffe          BL       Single_Read
00008e  4901              LDR      r1,|L5.148|
000090  7348              STRB     r0,[r1,#0xd]
;;;71     	
;;;72     }
000092  bd10              POP      {r4,pc}
;;;73     /**************************实现函数********************************************
                          ENDP

                  |L5.148|
                          DCD      mpu6050_buffer

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  mpu6050_buffer
                          %        16
                  sensor
                          %        104

                          AREA ||.data||, DATA, ALIGN=2

                  tempax
                          DCD      0x00000000
                  tempay
                          DCD      0x00000000
                  tempaz
                          DCD      0x00000000
                  cnt_a
00000c  00                DCB      0x00
                  over_flag
00000d  00                DCB      0x00
