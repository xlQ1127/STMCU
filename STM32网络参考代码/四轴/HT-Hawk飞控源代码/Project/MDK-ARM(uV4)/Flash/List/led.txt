; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections -c --asm --interleave -o.\flash\obj\led.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\led.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\User\usb_virture_com -I..\..\User -I..\..\User\bsp -I..\..\User\Driver\IIC -I..\..\User\Driver\LED -I..\..\User\Driver\TIM -I..\..\User\Driver\SPI -I..\..\User\Driver\ADC -I..\..\User\Driver\Delay -I..\..\User\Driver\UART -I..\..\User\Driver\MOTOR -I..\..\User\Driver\PWM_IN -I..\..\User\Driver\EEPROM -I..\..\User\Modules\Modules_mpu6050 -I..\..\User\Modules\Modules_nrf24L01 -I..\..\User\Modules\Modules_hmc5883 -I..\..\User\Algorithm\Algorithm_filter -I..\..\User\Algorithm\Algorithm_math -I..\..\User\Algorithm\Algorithm_sqLite -I..\..\User\Algorithm\Algorithm_quaternion -I..\..\User\Function\MultiRotor_rc -I..\..\User\Function\MultiRotor_app -I..\..\User\Function\MultiRotor_ahrs -I..\..\User\Function\MultiRotor_radio -I..\..\User\Function\MultiRotor_control -I..\..\User\Modules\Modules_oled -I..\..\User\Driver\STMFLASH -I.\RTE\_Flash -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\led.crf ..\..\User\Driver\LED\led.c]
                          THUMB

                          AREA ||i.FailSafeLEDAlarm||, CODE, READONLY, ALIGN=2

                  FailSafeLEDAlarm PROC
;;;160    /*====================================================================================================*/
;;;161    void FailSafeLEDAlarm(void)
000000  b510              PUSH     {r4,lr}
;;;162    {
;;;163    	if(flag.ARMED)
000002  481a              LDR      r0,|L1.108|
000004  7900              LDRB     r0,[r0,#4]  ; flag
000006  b110              CBZ      r0,|L1.14|
;;;164    		LED.event=Ht_ARMED;
000008  2000              MOVS     r0,#0
00000a  4919              LDR      r1,|L1.112|
00000c  7008              STRB     r0,[r1,#0]
                  |L1.14|
;;;165    	
;;;166    	if(!flag.ARMED)
00000e  4817              LDR      r0,|L1.108|
000010  7900              LDRB     r0,[r0,#4]  ; flag
000012  b910              CBNZ     r0,|L1.26|
;;;167    		LED.event=Ht_DISARMED;
000014  2001              MOVS     r0,#1
000016  4916              LDR      r1,|L1.112|
000018  7008              STRB     r0,[r1,#0]
                  |L1.26|
;;;168    	
;;;169    	if(flag.calibratingA)
00001a  4814              LDR      r0,|L1.108|
00001c  7980              LDRB     r0,[r0,#6]  ; flag
00001e  b110              CBZ      r0,|L1.38|
;;;170    		LED.event=Ht_CALIBRATA;
000020  2002              MOVS     r0,#2
000022  4913              LDR      r1,|L1.112|
000024  7008              STRB     r0,[r1,#0]
                  |L1.38|
;;;171    	
;;;172    	if(flag.calibratingA)		
000026  4811              LDR      r0,|L1.108|
000028  7980              LDRB     r0,[r0,#6]  ; flag
00002a  b110              CBZ      r0,|L1.50|
;;;173     		 LED.event=Ht_CALIBRATA;
00002c  2002              MOVS     r0,#2
00002e  4910              LDR      r1,|L1.112|
000030  7008              STRB     r0,[r1,#0]
                  |L1.50|
;;;174    	
;;;175    	if(flag.calibratingM){
000032  480e              LDR      r0,|L1.108|
000034  79c0              LDRB     r0,[r0,#7]  ; flag
000036  b1a8              CBZ      r0,|L1.100|
;;;176    		switch(flag.calibratingM)
000038  480c              LDR      r0,|L1.108|
00003a  79c0              LDRB     r0,[r0,#7]  ; flag
00003c  2801              CMP      r0,#1
00003e  d004              BEQ      |L1.74|
000040  2802              CMP      r0,#2
000042  d006              BEQ      |L1.82|
000044  2803              CMP      r0,#3
000046  d10c              BNE      |L1.98|
000048  e007              B        |L1.90|
                  |L1.74|
;;;177     	  {
;;;178    			case 1:LED.event=Ht_CALIBRATM_X; break;
00004a  2004              MOVS     r0,#4
00004c  4908              LDR      r1,|L1.112|
00004e  7008              STRB     r0,[r1,#0]
000050  e007              B        |L1.98|
                  |L1.82|
;;;179    			case 2:LED.event=Ht_CALIBRATM_Y; break;
000052  2005              MOVS     r0,#5
000054  4906              LDR      r1,|L1.112|
000056  7008              STRB     r0,[r1,#0]
000058  e003              B        |L1.98|
                  |L1.90|
;;;180    			case 3:LED.event=Ht_CALIBRATM_Z; break;
00005a  2006              MOVS     r0,#6
00005c  4904              LDR      r1,|L1.112|
00005e  7008              STRB     r0,[r1,#0]
000060  bf00              NOP      
                  |L1.98|
000062  bf00              NOP                            ;178
                  |L1.100|
;;;181    		}
;;;182    	}
;;;183    	LED_Fsm();
000064  f7fffffe          BL       LED_Fsm
;;;184    }
000068  bd10              POP      {r4,pc}
;;;185    
                          ENDP

00006a  0000              DCW      0x0000
                  |L1.108|
                          DCD      flag
                  |L1.112|
                          DCD      LED

                          AREA ||i.LEDReflash||, CODE, READONLY, ALIGN=2

                  LEDReflash PROC
;;;91     
;;;92     void LEDReflash(void)
000000  b510              PUSH     {r4,lr}
;;;93     {
;;;94     	if(LEDBuf.bits.R)
000002  4815              LDR      r0,|L2.88|
000004  7800              LDRB     r0,[r0,#0]  ; LEDBuf
000006  f0000001          AND      r0,r0,#1
00000a  b120              CBZ      r0,|L2.22|
;;;95     		Ledr_on;       //Ledg_on     【GPIO_ResetBits(GPIO_LED, LED_G)】
00000c  2101              MOVS     r1,#1
00000e  4813              LDR      r0,|L2.92|
000010  f7fffffe          BL       GPIO_ResetBits
000014  e003              B        |L2.30|
                  |L2.22|
;;;96     	else
;;;97     		Ledr_off;      //Ledr_off    【GPIO_SetBits(GPIO_LED, LED_R)】
000016  2101              MOVS     r1,#1
000018  4810              LDR      r0,|L2.92|
00001a  f7fffffe          BL       GPIO_SetBits
                  |L2.30|
;;;98     
;;;99     	if(LEDBuf.bits.G)
00001e  480e              LDR      r0,|L2.88|
000020  7800              LDRB     r0,[r0,#0]  ; LEDBuf
000022  f3c00040          UBFX     r0,r0,#1,#1
000026  b120              CBZ      r0,|L2.50|
;;;100    		Ledg_on;
000028  2102              MOVS     r1,#2
00002a  480c              LDR      r0,|L2.92|
00002c  f7fffffe          BL       GPIO_ResetBits
000030  e003              B        |L2.58|
                  |L2.50|
;;;101    	else
;;;102    		Ledg_off;
000032  2102              MOVS     r1,#2
000034  4809              LDR      r0,|L2.92|
000036  f7fffffe          BL       GPIO_SetBits
                  |L2.58|
;;;103    
;;;104    	if(LEDBuf.bits.B)
00003a  4807              LDR      r0,|L2.88|
00003c  7800              LDRB     r0,[r0,#0]  ; LEDBuf
00003e  f3c00080          UBFX     r0,r0,#2,#1
000042  b120              CBZ      r0,|L2.78|
;;;105    		Ledb_on;
000044  2104              MOVS     r1,#4
000046  4805              LDR      r0,|L2.92|
000048  f7fffffe          BL       GPIO_ResetBits
00004c  e003              B        |L2.86|
                  |L2.78|
;;;106    	else
;;;107    		Ledb_off;
00004e  2104              MOVS     r1,#4
000050  4802              LDR      r0,|L2.92|
000052  f7fffffe          BL       GPIO_SetBits
                  |L2.86|
;;;108    }
000056  bd10              POP      {r4,pc}
;;;109    /*====================================================================================================*/
                          ENDP

                  |L2.88|
                          DCD      LEDBuf
                  |L2.92|
                          DCD      0x40011400

                          AREA ||i.LED_Fsm||, CODE, READONLY, ALIGN=2

                  LED_Fsm PROC
;;;117    /*====================================================================================================*/
;;;118    void LED_Fsm(void)
000000  b510              PUSH     {r4,lr}
;;;119    {
;;;120     	switch(LED.event)
000002  482d              LDR      r0,|L3.184|
000004  7800              LDRB     r0,[r0,#0]  ; LED
000006  2807              CMP      r0,#7
000008  d251              BCS      |L3.174|
00000a  e8dff000          TBB      [pc,r0]
00000e  0422              DCB      0x04,0x22
000010  40504448          DCB      0x40,0x50,0x44,0x48
000014  4c00              DCB      0x4c,0x00
;;;121     	{
;;;122    	  case Ht_ARMED:       
;;;123    			if(++LED.cnt >= 120)  LED.cnt=0;
000016  4828              LDR      r0,|L3.184|
000018  8840              LDRH     r0,[r0,#2]  ; LED
00001a  1c40              ADDS     r0,r0,#1
00001c  b280              UXTH     r0,r0
00001e  4926              LDR      r1,|L3.184|
000020  8048              STRH     r0,[r1,#2]
000022  2878              CMP      r0,#0x78
000024  db01              BLT      |L3.42|
000026  2000              MOVS     r0,#0
000028  8048              STRH     r0,[r1,#2]
                  |L3.42|
;;;124    			if(LED.cnt<10 || (LED.cnt>20 && LED.cnt<30)) 
00002a  4823              LDR      r0,|L3.184|
00002c  8840              LDRH     r0,[r0,#2]  ; LED
00002e  280a              CMP      r0,#0xa
000030  db07              BLT      |L3.66|
000032  4821              LDR      r0,|L3.184|
000034  8840              LDRH     r0,[r0,#2]  ; LED
000036  2814              CMP      r0,#0x14
000038  dd07              BLE      |L3.74|
00003a  481f              LDR      r0,|L3.184|
00003c  8840              LDRH     r0,[r0,#2]  ; LED
00003e  281e              CMP      r0,#0x1e
000040  da03              BGE      |L3.74|
                  |L3.66|
;;;125    						LEDBuf.byte =LG|LB;
000042  2006              MOVS     r0,#6
000044  491d              LDR      r1,|L3.188|
000046  7008              STRB     r0,[r1,#0]
000048  e002              B        |L3.80|
                  |L3.74|
;;;126    				else
;;;127    						LEDBuf.byte =0;
00004a  2000              MOVS     r0,#0
00004c  491b              LDR      r1,|L3.188|
00004e  7008              STRB     r0,[r1,#0]
                  |L3.80|
;;;128    		  break;
000050  e02d              B        |L3.174|
;;;129    		case Ht_DISARMED:       
;;;130    			if(++LED.cnt >= 60) LED.cnt=0;
000052  4819              LDR      r0,|L3.184|
000054  8840              LDRH     r0,[r0,#2]  ; LED
000056  1c40              ADDS     r0,r0,#1
000058  b280              UXTH     r0,r0
00005a  4917              LDR      r1,|L3.184|
00005c  8048              STRH     r0,[r1,#2]
00005e  283c              CMP      r0,#0x3c
000060  db01              BLT      |L3.102|
000062  2000              MOVS     r0,#0
000064  8048              STRH     r0,[r1,#2]
                  |L3.102|
;;;131    		  if(LED.cnt<=20)
000066  4814              LDR      r0,|L3.184|
000068  8840              LDRH     r0,[r0,#2]  ; LED
00006a  2814              CMP      r0,#0x14
00006c  dc03              BGT      |L3.118|
;;;132    						LEDBuf.byte =LR;
00006e  2001              MOVS     r0,#1
000070  4912              LDR      r1,|L3.188|
000072  7008              STRB     r0,[r1,#0]
000074  e00a              B        |L3.140|
                  |L3.118|
;;;133    			else if(LED.cnt<=40)
000076  4810              LDR      r0,|L3.184|
000078  8840              LDRH     r0,[r0,#2]  ; LED
00007a  2828              CMP      r0,#0x28
00007c  dc03              BGT      |L3.134|
;;;134    						LEDBuf.byte =LG;
00007e  2002              MOVS     r0,#2
000080  490e              LDR      r1,|L3.188|
000082  7008              STRB     r0,[r1,#0]
000084  e002              B        |L3.140|
                  |L3.134|
;;;135    			else  LEDBuf.byte =LB;
000086  2004              MOVS     r0,#4
000088  490c              LDR      r1,|L3.188|
00008a  7008              STRB     r0,[r1,#0]
                  |L3.140|
;;;136    			break;	
00008c  e00f              B        |L3.174|
;;;137    		case Ht_CALIBRATA:           
;;;138             LEDBuf.byte =LB;
00008e  2004              MOVS     r0,#4
000090  490a              LDR      r1,|L3.188|
000092  7008              STRB     r0,[r1,#0]
;;;139    			break;
000094  e00b              B        |L3.174|
;;;140     		case Ht_CALIBRATM_X:         
;;;141              LEDBuf.byte =LR;
000096  2001              MOVS     r0,#1
000098  4908              LDR      r1,|L3.188|
00009a  7008              STRB     r0,[r1,#0]
;;;142     			break;
00009c  e007              B        |L3.174|
;;;143    		case Ht_CALIBRATM_Y:         
;;;144              LEDBuf.byte =LG;
00009e  2002              MOVS     r0,#2
0000a0  4906              LDR      r1,|L3.188|
0000a2  7008              STRB     r0,[r1,#0]
;;;145     			break;
0000a4  e003              B        |L3.174|
;;;146    		case Ht_CALIBRATM_Z:         
;;;147              LEDBuf.byte =LB;
0000a6  2004              MOVS     r0,#4
0000a8  4904              LDR      r1,|L3.188|
0000aa  7008              STRB     r0,[r1,#0]
;;;148     			break;
0000ac  bf00              NOP      
                  |L3.174|
0000ae  bf00              NOP                            ;128
;;;149     	}
;;;150    	LEDReflash();
0000b0  f7fffffe          BL       LEDReflash
;;;151    }
0000b4  bd10              POP      {r4,pc}
;;;152    /*====================================================================================================*/
                          ENDP

0000b6  0000              DCW      0x0000
                  |L3.184|
                          DCD      LED
                  |L3.188|
                          DCD      LEDBuf

                          AREA ||i.LED_GPIO_Config||, CODE, READONLY, ALIGN=2

                  LED_GPIO_Config PROC
;;;39      
;;;40     void LED_GPIO_Config(void)
000000  b508              PUSH     {r3,lr}
;;;41     {		
;;;42     	/*定义一个GPIO_InitTypeDef类型的结构体*/
;;;43     	GPIO_InitTypeDef GPIO_InitStructure;
;;;44     
;;;45     	/*开启GPIOB的外设时钟*/
;;;46     	RCC_APB2PeriphClockCmd( RCC_GPIO_LED, ENABLE); 
000002  2101              MOVS     r1,#1
000004  2020              MOVS     r0,#0x20
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;47     	RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOE, ENABLE); 
00000a  2101              MOVS     r1,#1
00000c  2040              MOVS     r0,#0x40
00000e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;48     	
;;;49     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
000012  2101              MOVS     r1,#1
000014  4608              MOV      r0,r1
000016  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;50     	//设置LED使用到得管脚
;;;51     	GPIO_PinRemapConfig(GPIO_Remap_SWJ_Disable, ENABLE);         //当用到调试的IO时 需要如此处理
00001a  2101              MOVS     r1,#1
00001c  4811              LDR      r0,|L4.100|
00001e  f7fffffe          BL       GPIO_PinRemapConfig
;;;52         GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable , ENABLE);    //将JTAG引脚作为普通IO使用
000022  2101              MOVS     r1,#1
000024  4810              LDR      r0,|L4.104|
000026  f7fffffe          BL       GPIO_PinRemapConfig
;;;53     
;;;54     	/*选择要控制的GPIOD引脚*/															   
;;;55       	GPIO_InitStructure.GPIO_Pin = LED_R | LED_G | LED_B;	     //========================【GPIOD 0，1，2管脚】
00002a  2007              MOVS     r0,#7
00002c  f8ad0000          STRH     r0,[sp,#0]
;;;56     
;;;57     	/*设置引脚模式为通用推挽输出*/
;;;58       	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;   
000030  2010              MOVS     r0,#0x10
000032  f88d0003          STRB     r0,[sp,#3]
;;;59     
;;;60     	/*设置引脚速率为50MHz */   
;;;61       	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; 
000036  2003              MOVS     r0,#3
000038  f88d0002          STRB     r0,[sp,#2]
;;;62     
;;;63     	/*调用库函数，初始化GPIOB*/
;;;64       	GPIO_Init(GPIO_LED, &GPIO_InitStructure);		             //GPIOD引脚初始化
00003c  4669              MOV      r1,sp
00003e  480b              LDR      r0,|L4.108|
000040  f7fffffe          BL       GPIO_Init
;;;65     
;;;66     	/* 关闭所有led灯	*/
;;;67     	GPIO_SetBits(GPIO_LED, LED_R | LED_G | LED_B);	             //LED为低电平驱动
000044  2107              MOVS     r1,#7
000046  4809              LDR      r0,|L4.108|
000048  f7fffffe          BL       GPIO_SetBits
;;;68     	
;;;69     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6;	
00004c  2078              MOVS     r0,#0x78
00004e  f8ad0000          STRH     r0,[sp,#0]
;;;70     	
;;;71         GPIO_Init(GPIOE, &GPIO_InitStructure);	                     //GPIOE管脚初始化
000052  4669              MOV      r1,sp
000054  4806              LDR      r0,|L4.112|
000056  f7fffffe          BL       GPIO_Init
;;;72         GPIO_SetBits(GPIOE, GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6);	//============【PE3-4-5-6】
00005a  2178              MOVS     r1,#0x78
00005c  4804              LDR      r0,|L4.112|
00005e  f7fffffe          BL       GPIO_SetBits
;;;73     }
000062  bd08              POP      {r3,pc}
;;;74     void LED_SHOW(void)  //【LED全闪烁】
                          ENDP

                  |L4.100|
                          DCD      0x00300400
                  |L4.104|
                          DCD      0x00300200
                  |L4.108|
                          DCD      0x40011400
                  |L4.112|
                          DCD      0x40011800

                          AREA ||i.LED_SHOW||, CODE, READONLY, ALIGN=2

                  LED_SHOW PROC
;;;73     }
;;;74     void LED_SHOW(void)  //【LED全闪烁】
000000  b510              PUSH     {r4,lr}
;;;75     {
;;;76          LED_ALLON();    //LED_ALLON()    GPIO_ResetBits(GPIO_LED, LED_R | LED_G | LED_B)		GPIOD 0 1 2
000002  2107              MOVS     r1,#7
000004  4819              LDR      r0,|L5.108|
000006  f7fffffe          BL       GPIO_ResetBits
;;;77     	 delay(900);
00000a  f44f7061          MOV      r0,#0x384
00000e  f7fffffe          BL       delay
;;;78     	 LED_ALLOFF();   //LED_ALLOFF()	GPIO_SetBits(GPIO_LED, LED_R | LED_G | LED_B)
000012  2107              MOVS     r1,#7
000014  4815              LDR      r0,|L5.108|
000016  f7fffffe          BL       GPIO_SetBits
;;;79     	 delay(16000);
00001a  f44f507a          MOV      r0,#0x3e80
00001e  f7fffffe          BL       delay
;;;80     	 LED_ALLON();
000022  2107              MOVS     r1,#7
000024  4811              LDR      r0,|L5.108|
000026  f7fffffe          BL       GPIO_ResetBits
;;;81     	 delay(900);
00002a  f44f7061          MOV      r0,#0x384
00002e  f7fffffe          BL       delay
;;;82     	 LED_ALLOFF();
000032  2107              MOVS     r1,#7
000034  480d              LDR      r0,|L5.108|
000036  f7fffffe          BL       GPIO_SetBits
;;;83     	 delay(16000);
00003a  f44f507a          MOV      r0,#0x3e80
00003e  f7fffffe          BL       delay
;;;84     	 LED_ALLON();
000042  2107              MOVS     r1,#7
000044  4809              LDR      r0,|L5.108|
000046  f7fffffe          BL       GPIO_ResetBits
;;;85     	 delay(900);
00004a  f44f7061          MOV      r0,#0x384
00004e  f7fffffe          BL       delay
;;;86     	 LED_ALLOFF();
000052  2107              MOVS     r1,#7
000054  4805              LDR      r0,|L5.108|
000056  f7fffffe          BL       GPIO_SetBits
;;;87     	 delay(16000);
00005a  f44f507a          MOV      r0,#0x3e80
00005e  f7fffffe          BL       delay
;;;88     	 LED_ALLON();
000062  2107              MOVS     r1,#7
000064  4801              LDR      r0,|L5.108|
000066  f7fffffe          BL       GPIO_ResetBits
;;;89     }
00006a  bd10              POP      {r4,pc}
;;;90     
                          ENDP

                  |L5.108|
                          DCD      0x40011400

                          AREA ||.data||, DATA, ALIGN=1

                  LED
                          DCDU     0x00000000
                  LEDBuf
000004  00                DCB      0x00
