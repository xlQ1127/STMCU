; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections -c --asm --interleave -o.\flash\obj\usart.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\usart.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\User\usb_virture_com -I..\..\User -I..\..\User\bsp -I..\..\User\Driver\IIC -I..\..\User\Driver\LED -I..\..\User\Driver\TIM -I..\..\User\Driver\SPI -I..\..\User\Driver\ADC -I..\..\User\Driver\Delay -I..\..\User\Driver\UART -I..\..\User\Driver\MOTOR -I..\..\User\Driver\PWM_IN -I..\..\User\Driver\EEPROM -I..\..\User\Modules\Modules_mpu6050 -I..\..\User\Modules\Modules_nrf24L01 -I..\..\User\Modules\Modules_hmc5883 -I..\..\User\Algorithm\Algorithm_filter -I..\..\User\Algorithm\Algorithm_math -I..\..\User\Algorithm\Algorithm_sqLite -I..\..\User\Algorithm\Algorithm_quaternion -I..\..\User\Function\MultiRotor_rc -I..\..\User\Function\MultiRotor_app -I..\..\User\Function\MultiRotor_ahrs -I..\..\User\Function\MultiRotor_radio -I..\..\User\Function\MultiRotor_control -I..\..\User\Modules\Modules_oled -I..\..\User\Driver\STMFLASH -I.\RTE\_Flash -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\usart.crf ..\..\User\Driver\UART\usart.c]
                          THUMB

                          AREA ||i.UART1_Put_Char||, CODE, READONLY, ALIGN=2

                  UART1_Put_Char PROC
;;;61     *******************************************************************************/
;;;62     uint8_t UART1_Put_Char(unsigned char DataToSend)
000000  b510              PUSH     {r4,lr}
;;;63     {
000002  4604              MOV      r4,r0
;;;64     	//将要发送的字节写到UART1的发送缓冲区
;;;65     	USART_SendData(USART1, (unsigned char) DataToSend);
000004  4621              MOV      r1,r4
000006  4806              LDR      r0,|L1.32|
000008  f7fffffe          BL       USART_SendData
;;;66     	//等待发送完成
;;;67       	while (!(USART1->SR & USART_FLAG_TXE));
00000c  bf00              NOP      
                  |L1.14|
00000e  4804              LDR      r0,|L1.32|
000010  8800              LDRH     r0,[r0,#0]
000012  f0000080          AND      r0,r0,#0x80
000016  2800              CMP      r0,#0
000018  d0f9              BEQ      |L1.14|
;;;68     	return DataToSend;
00001a  4620              MOV      r0,r4
;;;69     }
00001c  bd10              POP      {r4,pc}
;;;70     
                          ENDP

00001e  0000              DCW      0x0000
                  |L1.32|
                          DCD      0x40013800

                          AREA ||i.UART2_Put_Char||, CODE, READONLY, ALIGN=2

                  UART2_Put_Char PROC
;;;250    *******************************************************************************/
;;;251    uint8_t UART2_Put_Char(unsigned char DataToSend)
000000  b510              PUSH     {r4,lr}
;;;252    {
000002  4604              MOV      r4,r0
;;;253    	//将要发送的字节写到UART1的发送缓冲区
;;;254    	USART_SendData(USART2, (unsigned char) DataToSend);
000004  4621              MOV      r1,r4
000006  4806              LDR      r0,|L2.32|
000008  f7fffffe          BL       USART_SendData
;;;255    	//等待发送完成
;;;256      	while (!(USART2->SR & USART_FLAG_TXE));
00000c  bf00              NOP      
                  |L2.14|
00000e  4804              LDR      r0,|L2.32|
000010  8800              LDRH     r0,[r0,#0]
000012  f0000080          AND      r0,r0,#0x80
000016  2800              CMP      r0,#0
000018  d0f9              BEQ      |L2.14|
;;;257    	return DataToSend;
00001a  4620              MOV      r0,r4
;;;258    }
00001c  bd10              POP      {r4,pc}
;;;259    
                          ENDP

00001e  0000              DCW      0x0000
                  |L2.32|
                          DCD      0x40004400

                          AREA ||i.USART1_Config||, CODE, READONLY, ALIGN=2

                  USART1_Config PROC
;;;14     
;;;15     void USART1_Config(void)
000000  b500              PUSH     {lr}
;;;16     {
000002  b085              SUB      sp,sp,#0x14
;;;17     	GPIO_InitTypeDef GPIO_InitStructure;
;;;18     	USART_InitTypeDef USART_InitStructure;
;;;19     	
;;;20     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE);
000004  2101              MOVS     r1,#1
000006  f2440004          MOV      r0,#0x4004
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;21     	
;;;22     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
00000e  f44f7000          MOV      r0,#0x200
000012  f8ad0010          STRH     r0,[sp,#0x10]
;;;23     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000016  2018              MOVS     r0,#0x18
000018  f88d0013          STRB     r0,[sp,#0x13]
;;;24     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00001c  2003              MOVS     r0,#3
00001e  f88d0012          STRB     r0,[sp,#0x12]
;;;25     	GPIO_Init(GPIOA, &GPIO_InitStructure);
000022  a904              ADD      r1,sp,#0x10
000024  4816              LDR      r0,|L3.128|
000026  f7fffffe          BL       GPIO_Init
;;;26     	
;;;27     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
00002a  f44f6080          MOV      r0,#0x400
00002e  f8ad0010          STRH     r0,[sp,#0x10]
;;;28     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000032  2004              MOVS     r0,#4
000034  f88d0013          STRB     r0,[sp,#0x13]
;;;29     	GPIO_Init(GPIOA, &GPIO_InitStructure);
000038  a904              ADD      r1,sp,#0x10
00003a  4811              LDR      r0,|L3.128|
00003c  f7fffffe          BL       GPIO_Init
;;;30     	
;;;31     	// 设置波特率
;;;32     	USART_InitStructure.USART_BaudRate = 57600;   
000040  f44f4061          MOV      r0,#0xe100
000044  9000              STR      r0,[sp,#0]
;;;33     	
;;;34     	// 设置数据位为8位
;;;35       USART_InitStructure.USART_WordLength = USART_WordLength_8b; 
000046  2000              MOVS     r0,#0
000048  f8ad0004          STRH     r0,[sp,#4]
;;;36     
;;;37       // 设置停止位为1位	
;;;38       USART_InitStructure.USART_StopBits = USART_StopBits_1;  
00004c  f8ad0006          STRH     r0,[sp,#6]
;;;39     
;;;40       // 无奇偶校验
;;;41       USART_InitStructure.USART_Parity = USART_Parity_No;  
000050  f8ad0008          STRH     r0,[sp,#8]
;;;42     
;;;43       // 没有硬件流控
;;;44       USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; 
000054  f8ad000c          STRH     r0,[sp,#0xc]
;;;45     	
;;;46     	// 发送与接收
;;;47       USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;     
000058  200c              MOVS     r0,#0xc
00005a  f8ad000a          STRH     r0,[sp,#0xa]
;;;48         
;;;49     	/*完成串口COM1的时钟配置、GPIO配置，根据上述参数初始化并使能*/
;;;50     	USART_Init(USART1, &USART_InitStructure);
00005e  4669              MOV      r1,sp
000060  4808              LDR      r0,|L3.132|
000062  f7fffffe          BL       USART_Init
;;;51     	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
000066  2201              MOVS     r2,#1
000068  f2405125          MOV      r1,#0x525
00006c  4805              LDR      r0,|L3.132|
00006e  f7fffffe          BL       USART_ITConfig
;;;52     	USART_Cmd(USART1, ENABLE);
000072  2101              MOVS     r1,#1
000074  4803              LDR      r0,|L3.132|
000076  f7fffffe          BL       USART_Cmd
;;;53     }
00007a  b005              ADD      sp,sp,#0x14
00007c  bd00              POP      {pc}
;;;54     
                          ENDP

00007e  0000              DCW      0x0000
                  |L3.128|
                          DCD      0x40010800
                  |L3.132|
                          DCD      0x40013800

                          AREA ||i.USART1_printf||, CODE, READONLY, ALIGN=1

                  USART1_printf PROC
;;;144     */
;;;145    void USART1_printf(USART_TypeDef* USARTx, uint8_t *Data,...)
000000  b40f              PUSH     {r0-r3}
;;;146    {
000002  b570              PUSH     {r4-r6,lr}
000004  b086              SUB      sp,sp,#0x18
000006  4606              MOV      r6,r0
;;;147    	const char *s;
;;;148      int d;   
;;;149      char buf[16];
;;;150    
;;;151      va_list ap;
;;;152      va_start(ap, Data);
000008  a80c              ADD      r0,sp,#0x30
00000a  9001              STR      r0,[sp,#4]
;;;153    
;;;154    	while ( *Data != 0)     // 判断是否到达字符串结束符
00000c  e073              B        |L4.246|
                  |L4.14|
;;;155    	{				                          
;;;156    		if ( *Data == 0x5c )  //'\'
00000e  980b              LDR      r0,[sp,#0x2c]
000010  7800              LDRB     r0,[r0,#0]
000012  285c              CMP      r0,#0x5c
000014  d11c              BNE      |L4.80|
;;;157    		{									  
;;;158    			switch ( *++Data )
000016  980b              LDR      r0,[sp,#0x2c]
000018  1c40              ADDS     r0,r0,#1
00001a  900b              STR      r0,[sp,#0x2c]
00001c  7800              LDRB     r0,[r0,#0]
00001e  286e              CMP      r0,#0x6e
000020  d009              BEQ      |L4.54|
000022  2872              CMP      r0,#0x72
000024  d10f              BNE      |L4.70|
;;;159    			{
;;;160    				case 'r':							          //回车符
;;;161    					USART_SendData(USARTx, 0x0d);
000026  210d              MOVS     r1,#0xd
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       USART_SendData
;;;162    					Data ++;
00002e  980b              LDR      r0,[sp,#0x2c]
000030  1c40              ADDS     r0,r0,#1
000032  900b              STR      r0,[sp,#0x2c]
;;;163    					break;
000034  e00b              B        |L4.78|
                  |L4.54|
;;;164    
;;;165    				case 'n':							          //换行符
;;;166    					USART_SendData(USARTx, 0x0a);	
000036  210a              MOVS     r1,#0xa
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       USART_SendData
;;;167    					Data ++;
00003e  980b              LDR      r0,[sp,#0x2c]
000040  1c40              ADDS     r0,r0,#1
000042  900b              STR      r0,[sp,#0x2c]
;;;168    					break;
000044  e003              B        |L4.78|
                  |L4.70|
;;;169    				
;;;170    				default:
;;;171    					Data ++;
000046  980b              LDR      r0,[sp,#0x2c]
000048  1c40              ADDS     r0,r0,#1
00004a  900b              STR      r0,[sp,#0x2c]
;;;172    				    break;
00004c  bf00              NOP      
                  |L4.78|
00004e  e04b              B        |L4.232|
                  |L4.80|
;;;173    			}			 
;;;174    		}
;;;175    		else if ( *Data == '%')
000050  980b              LDR      r0,[sp,#0x2c]
000052  7800              LDRB     r0,[r0,#0]
000054  2825              CMP      r0,#0x25
000056  d140              BNE      |L4.218|
;;;176    		{									  //
;;;177    			switch ( *++Data )
000058  980b              LDR      r0,[sp,#0x2c]
00005a  1c40              ADDS     r0,r0,#1
00005c  900b              STR      r0,[sp,#0x2c]
00005e  7800              LDRB     r0,[r0,#0]
000060  2864              CMP      r0,#0x64
000062  d018              BEQ      |L4.150|
000064  2873              CMP      r0,#0x73
000066  d133              BNE      |L4.208|
;;;178    			{				
;;;179    				case 's':										  //字符串
;;;180    					s = va_arg(ap, const char *);
000068  9801              LDR      r0,[sp,#4]
00006a  c810              LDM      r0!,{r4}
00006c  9001              STR      r0,[sp,#4]
;;;181              for ( ; *s; s++) 
00006e  e00b              B        |L4.136|
                  |L4.112|
;;;182    					{
;;;183    						USART_SendData(USARTx,*s);
000070  7821              LDRB     r1,[r4,#0]
000072  4630              MOV      r0,r6
000074  f7fffffe          BL       USART_SendData
;;;184    						while( USART_GetFlagStatus(USARTx, USART_FLAG_TC) == RESET );
000078  bf00              NOP      
                  |L4.122|
00007a  2140              MOVS     r1,#0x40
00007c  4630              MOV      r0,r6
00007e  f7fffffe          BL       USART_GetFlagStatus
000082  2800              CMP      r0,#0
000084  d0f9              BEQ      |L4.122|
000086  1c64              ADDS     r4,r4,#1              ;181
                  |L4.136|
000088  7820              LDRB     r0,[r4,#0]            ;181
00008a  2800              CMP      r0,#0                 ;181
00008c  d1f0              BNE      |L4.112|
;;;185              }
;;;186    					Data++;
00008e  980b              LDR      r0,[sp,#0x2c]
000090  1c40              ADDS     r0,r0,#1
000092  900b              STR      r0,[sp,#0x2c]
;;;187              break;
000094  e020              B        |L4.216|
                  |L4.150|
;;;188    
;;;189            case 'd':										//十进制
;;;190              d = va_arg(ap, int);
000096  9801              LDR      r0,[sp,#4]
000098  c820              LDM      r0!,{r5}
00009a  9001              STR      r0,[sp,#4]
;;;191              itoa(d, buf, 10);
00009c  220a              MOVS     r2,#0xa
00009e  a902              ADD      r1,sp,#8
0000a0  4628              MOV      r0,r5
0000a2  f7fffffe          BL       itoa
;;;192              for (s = buf; *s; s++) 
0000a6  ac02              ADD      r4,sp,#8
0000a8  e00b              B        |L4.194|
                  |L4.170|
;;;193    					{
;;;194    						USART_SendData(USARTx,*s);
0000aa  7821              LDRB     r1,[r4,#0]
0000ac  4630              MOV      r0,r6
0000ae  f7fffffe          BL       USART_SendData
;;;195    						while( USART_GetFlagStatus(USARTx, USART_FLAG_TC) == RESET );
0000b2  bf00              NOP      
                  |L4.180|
0000b4  2140              MOVS     r1,#0x40
0000b6  4630              MOV      r0,r6
0000b8  f7fffffe          BL       USART_GetFlagStatus
0000bc  2800              CMP      r0,#0
0000be  d0f9              BEQ      |L4.180|
0000c0  1c64              ADDS     r4,r4,#1              ;192
                  |L4.194|
0000c2  7820              LDRB     r0,[r4,#0]            ;192
0000c4  2800              CMP      r0,#0                 ;192
0000c6  d1f0              BNE      |L4.170|
;;;196              }
;;;197    					Data++;
0000c8  980b              LDR      r0,[sp,#0x2c]
0000ca  1c40              ADDS     r0,r0,#1
0000cc  900b              STR      r0,[sp,#0x2c]
;;;198              break;
0000ce  e003              B        |L4.216|
                  |L4.208|
;;;199    				 default:
;;;200    						Data++;
0000d0  980b              LDR      r0,[sp,#0x2c]
0000d2  1c40              ADDS     r0,r0,#1
0000d4  900b              STR      r0,[sp,#0x2c]
;;;201    				    break;
0000d6  bf00              NOP      
                  |L4.216|
0000d8  e006              B        |L4.232|
                  |L4.218|
;;;202    			}		 
;;;203    		} /* end of else if */
;;;204    		else USART_SendData(USARTx, *Data++);
0000da  980b              LDR      r0,[sp,#0x2c]
0000dc  f8101b01          LDRB     r1,[r0],#1
0000e0  900b              STR      r0,[sp,#0x2c]
0000e2  4630              MOV      r0,r6
0000e4  f7fffffe          BL       USART_SendData
                  |L4.232|
;;;205    		while( USART_GetFlagStatus(USARTx, USART_FLAG_TC) == RESET );
0000e8  bf00              NOP      
                  |L4.234|
0000ea  2140              MOVS     r1,#0x40
0000ec  4630              MOV      r0,r6
0000ee  f7fffffe          BL       USART_GetFlagStatus
0000f2  2800              CMP      r0,#0
0000f4  d0f9              BEQ      |L4.234|
                  |L4.246|
0000f6  980b              LDR      r0,[sp,#0x2c]         ;154
0000f8  7800              LDRB     r0,[r0,#0]            ;154
0000fa  2800              CMP      r0,#0                 ;154
0000fc  d187              BNE      |L4.14|
;;;206    	}
;;;207    }
0000fe  b006              ADD      sp,sp,#0x18
000100  bc70              POP      {r4-r6}
000102  f85dfb14          LDR      pc,[sp],#0x14
;;;208    
                          ENDP


                          AREA ||i.itoa||, CODE, READONLY, ALIGN=1

                  itoa PROC
;;;83      */
;;;84     static char *itoa(int value, char *string, int radix)
000000  b5f0              PUSH     {r4-r7,lr}
;;;85     {
000002  4603              MOV      r3,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;86         int     i, d;
;;;87         int     flag = 0;
000008  2700              MOVS     r7,#0
;;;88         char    *ptr = string;
00000a  4629              MOV      r1,r5
;;;89     
;;;90         /* This implementation only works for decimal numbers. */
;;;91         if (radix != 10)
00000c  2e0a              CMP      r6,#0xa
00000e  d003              BEQ      |L5.24|
;;;92         {
;;;93             *ptr = 0;
000010  2000              MOVS     r0,#0
000012  7008              STRB     r0,[r1,#0]
;;;94             return string;
000014  4628              MOV      r0,r5
                  |L5.22|
;;;95         }
;;;96     
;;;97         if (!value)
;;;98         {
;;;99             *ptr++ = 0x30;
;;;100            *ptr = 0;
;;;101            return string;
;;;102        }
;;;103    
;;;104        /* if this is a negative value insert the minus sign. */
;;;105        if (value < 0)
;;;106        {
;;;107            *ptr++ = '-';
;;;108    
;;;109            /* Make the value positive. */
;;;110            value *= -1;
;;;111        }
;;;112    
;;;113        for (i = 10000; i > 0; i /= 10)
;;;114        {
;;;115            d = value / i;
;;;116    
;;;117            if (d || flag)
;;;118            {
;;;119                *ptr++ = (char)(d + 0x30);
;;;120                value -= (d * i);
;;;121                flag = 1;
;;;122            }
;;;123        }
;;;124    
;;;125        /* Null terminate the string. */
;;;126        *ptr = 0;
;;;127    
;;;128        return string;
;;;129    
;;;130    } /* NCL_Itoa */
000016  bdf0              POP      {r4-r7,pc}
                  |L5.24|
000018  b933              CBNZ     r3,|L5.40|
00001a  2030              MOVS     r0,#0x30              ;99
00001c  f8010b01          STRB     r0,[r1],#1            ;99
000020  2000              MOVS     r0,#0                 ;100
000022  7008              STRB     r0,[r1,#0]            ;100
000024  4628              MOV      r0,r5                 ;101
000026  e7f6              B        |L5.22|
                  |L5.40|
000028  2b00              CMP      r3,#0                 ;105
00002a  da03              BGE      |L5.52|
00002c  202d              MOVS     r0,#0x2d              ;107
00002e  f8010b01          STRB     r0,[r1],#1            ;107
000032  425b              RSBS     r3,r3,#0              ;110
                  |L5.52|
000034  f2427210          MOV      r2,#0x2710            ;113
000038  e00d              B        |L5.86|
                  |L5.58|
00003a  fb93f4f2          SDIV     r4,r3,r2              ;115
00003e  b904              CBNZ     r4,|L5.66|
000040  b137              CBZ      r7,|L5.80|
                  |L5.66|
000042  f1040030          ADD      r0,r4,#0x30           ;119
000046  f8010b01          STRB     r0,[r1],#1            ;119
00004a  fb043312          MLS      r3,r4,r2,r3           ;120
00004e  2701              MOVS     r7,#1                 ;121
                  |L5.80|
000050  200a              MOVS     r0,#0xa               ;113
000052  fb92f2f0          SDIV     r2,r2,r0              ;113
                  |L5.86|
000056  2a00              CMP      r2,#0                 ;113
000058  dcef              BGT      |L5.58|
00005a  2000              MOVS     r0,#0                 ;126
00005c  7008              STRB     r0,[r1,#0]            ;126
00005e  4628              MOV      r0,r5                 ;128
000060  e7d9              B        |L5.22|
;;;131    
                          ENDP


                          AREA ||i.usart2_config||, CODE, READONLY, ALIGN=2

                  usart2_config PROC
;;;208    
;;;209    void usart2_config(void)
000000  b500              PUSH     {lr}
;;;210    {
000002  b085              SUB      sp,sp,#0x14
;;;211    	GPIO_InitTypeDef GPIO_InitStructure;
;;;212    	USART_InitTypeDef USART_InitStructure;
;;;213    	
;;;214    		/* config USART2 clock */
;;;215    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE);
000004  2101              MOVS     r1,#1
000006  2020              MOVS     r0,#0x20
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;216    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0448              LSLS     r0,r1,#17
000010  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;217      RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);  //使能AFIO功能的时钟
000014  2101              MOVS     r1,#1
000016  4608              MOV      r0,r1
000018  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;218      GPIO_PinRemapConfig(GPIO_Remap_USART2 ,ENABLE);  //进行重映射
00001c  2101              MOVS     r1,#1
00001e  2008              MOVS     r0,#8
000020  f7fffffe          BL       GPIO_PinRemapConfig
;;;219    	
;;;220    	
;;;221      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
000024  2020              MOVS     r0,#0x20
000026  f8ad0010          STRH     r0,[sp,#0x10]
;;;222      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00002a  2018              MOVS     r0,#0x18
00002c  f88d0013          STRB     r0,[sp,#0x13]
;;;223      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000030  2003              MOVS     r0,#3
000032  f88d0012          STRB     r0,[sp,#0x12]
;;;224      GPIO_Init(GPIOD, &GPIO_InitStructure);
000036  a904              ADD      r1,sp,#0x10
000038  4815              LDR      r0,|L6.144|
00003a  f7fffffe          BL       GPIO_Init
;;;225    	    
;;;226      /* Configure USART2 Rx (PD.09) as input floating */
;;;227      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
00003e  2040              MOVS     r0,#0x40
000040  f8ad0010          STRH     r0,[sp,#0x10]
;;;228      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000044  2004              MOVS     r0,#4
000046  f88d0013          STRB     r0,[sp,#0x13]
;;;229      GPIO_Init(GPIOD, &GPIO_InitStructure);
00004a  a904              ADD      r1,sp,#0x10
00004c  4810              LDR      r0,|L6.144|
00004e  f7fffffe          BL       GPIO_Init
;;;230    	
;;;231    	  USART_InitStructure.USART_BaudRate = 9600;                 /*设置波特率为115200*/
000052  f44f5016          MOV      r0,#0x2580
000056  9000              STR      r0,[sp,#0]
;;;232        USART_InitStructure.USART_WordLength = USART_WordLength_8b;  /*设置数据位为8位*/
000058  2000              MOVS     r0,#0
00005a  f8ad0004          STRH     r0,[sp,#4]
;;;233        USART_InitStructure.USART_StopBits = USART_StopBits_1;       /*设置停止位为1位*/
00005e  f8ad0006          STRH     r0,[sp,#6]
;;;234        USART_InitStructure.USART_Parity = USART_Parity_No;          /*无奇偶校验*/    
000062  f8ad0008          STRH     r0,[sp,#8]
;;;235        USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; /*没有硬件流控*/
000066  f8ad000c          STRH     r0,[sp,#0xc]
;;;236        USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;      /*发送与接收*/
00006a  200c              MOVS     r0,#0xc
00006c  f8ad000a          STRH     r0,[sp,#0xa]
;;;237        /*完成串口COM3的时钟配置、GPIO配置，根据上述参数初始化并使能*/
;;;238    	
;;;239    	USART_Init(USART2, &USART_InitStructure);
000070  4669              MOV      r1,sp
000072  4808              LDR      r0,|L6.148|
000074  f7fffffe          BL       USART_Init
;;;240    	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
000078  2201              MOVS     r2,#1
00007a  f2405125          MOV      r1,#0x525
00007e  4805              LDR      r0,|L6.148|
000080  f7fffffe          BL       USART_ITConfig
;;;241    	USART_Cmd(USART2, ENABLE);
000084  2101              MOVS     r1,#1
000086  4803              LDR      r0,|L6.148|
000088  f7fffffe          BL       USART_Cmd
;;;242    }
00008c  b005              ADD      sp,sp,#0x14
00008e  bd00              POP      {pc}
;;;243    
                          ENDP

                  |L6.144|
                          DCD      0x40011400
                  |L6.148|
                          DCD      0x40004400
