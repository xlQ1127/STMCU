; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections -c --asm --interleave -o.\flash\obj\multirotor_ahrs.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\multirotor_ahrs.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\User\usb_virture_com -I..\..\User -I..\..\User\bsp -I..\..\User\Driver\IIC -I..\..\User\Driver\LED -I..\..\User\Driver\TIM -I..\..\User\Driver\SPI -I..\..\User\Driver\ADC -I..\..\User\Driver\Delay -I..\..\User\Driver\UART -I..\..\User\Driver\MOTOR -I..\..\User\Driver\PWM_IN -I..\..\User\Driver\EEPROM -I..\..\User\Modules\Modules_mpu6050 -I..\..\User\Modules\Modules_nrf24L01 -I..\..\User\Modules\Modules_hmc5883 -I..\..\User\Algorithm\Algorithm_filter -I..\..\User\Algorithm\Algorithm_math -I..\..\User\Algorithm\Algorithm_sqLite -I..\..\User\Algorithm\Algorithm_quaternion -I..\..\User\Function\MultiRotor_rc -I..\..\User\Function\MultiRotor_app -I..\..\User\Function\MultiRotor_ahrs -I..\..\User\Function\MultiRotor_radio -I..\..\User\Function\MultiRotor_control -I..\..\User\Modules\Modules_oled -I..\..\User\Driver\STMFLASH -I.\RTE\_Flash -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\multirotor_ahrs.crf ..\..\User\Function\MultiRotor_ahrs\MultiRotor_ahrs.c]
                          THUMB

                          AREA ||i.AHRS_GetQ||, CODE, READONLY, ALIGN=2

                  AHRS_GetQ PROC
;;;72     /*====================================================================================================*/
;;;73     void AHRS_GetQ( Quaternion *pNumQ )
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;74     {
000004  b093              SUB      sp,sp,#0x4c
;;;75       fp32 ErrX, ErrY, ErrZ;
;;;76       fp32 AccX, AccY, AccZ;
;;;77       fp32 GyrX, GyrY, GyrZ;
;;;78       fp32 Normalize;
;;;79       static fp32 exInt = 0.0f, eyInt = 0.0f, ezInt = 0.0f;
;;;80       Gravity V;
;;;81     	
;;;82       // 加速度归一化   Q_rsqurt（） 倒数运算
;;;83       Normalize = Q_rsqrt(squa(sensor.acc.averag.x)+ squa(sensor.acc.averag.y) +squa(sensor.acc.averag.z));
000006  4a8f              LDR      r2,|L1.580|
000008  6911              LDR      r1,[r2,#0x10]
00000a  6910              LDR      r0,[r2,#0x10]
00000c  f7fffffe          BL       __aeabi_fmul
000010  4607              MOV      r7,r0
000012  4a8c              LDR      r2,|L1.580|
000014  68d1              LDR      r1,[r2,#0xc]
000016  68d0              LDR      r0,[r2,#0xc]
000018  f7fffffe          BL       __aeabi_fmul
00001c  4680              MOV      r8,r0
00001e  4a89              LDR      r2,|L1.580|
000020  6891              LDR      r1,[r2,#8]  ; sensor
000022  6890              LDR      r0,[r2,#8]  ; sensor
000024  f7fffffe          BL       __aeabi_fmul
000028  4683              MOV      r11,r0
00002a  4641              MOV      r1,r8
00002c  f7fffffe          BL       __aeabi_fadd
000030  4605              MOV      r5,r0
000032  4639              MOV      r1,r7
000034  f7fffffe          BL       __aeabi_fadd
000038  4606              MOV      r6,r0
00003a  f7fffffe          BL       Q_rsqrt
00003e  900b              STR      r0,[sp,#0x2c]
;;;84       AccX = sensor.acc.averag.x*Normalize;
000040  4980              LDR      r1,|L1.580|
000042  6888              LDR      r0,[r1,#8]  ; sensor
000044  990b              LDR      r1,[sp,#0x2c]
000046  f7fffffe          BL       __aeabi_fmul
00004a  9011              STR      r0,[sp,#0x44]
;;;85       AccY = sensor.acc.averag.y*Normalize;
00004c  497d              LDR      r1,|L1.580|
00004e  68c8              LDR      r0,[r1,#0xc]
000050  990b              LDR      r1,[sp,#0x2c]
000052  f7fffffe          BL       __aeabi_fmul
000056  9010              STR      r0,[sp,#0x40]
;;;86       AccZ = sensor.acc.averag.z*Normalize;
000058  497a              LDR      r1,|L1.580|
00005a  6908              LDR      r0,[r1,#0x10]
00005c  990b              LDR      r1,[sp,#0x2c]
00005e  f7fffffe          BL       __aeabi_fmul
000062  900f              STR      r0,[sp,#0x3c]
;;;87     
;;;88       // 提取重力分量
;;;89       V = Quaternion_vectorGravity(&NumQ);
000064  4978              LDR      r1,|L1.584|
000066  a805              ADD      r0,sp,#0x14
000068  f7fffffe          BL       Quaternion_vectorGravity
00006c  ad05              ADD      r5,sp,#0x14
00006e  9805              LDR      r0,[sp,#0x14]
000070  9008              STR      r0,[sp,#0x20]
000072  9806              LDR      r0,[sp,#0x18]
000074  9009              STR      r0,[sp,#0x24]
000076  9807              LDR      r0,[sp,#0x1c]
000078  900a              STR      r0,[sp,#0x28]
;;;90     	
;;;91       // 向量差乘 求解坐标系误差
;;;92       ErrX = (AccY*V.z - AccZ*V.y);
00007a  9909              LDR      r1,[sp,#0x24]
00007c  980f              LDR      r0,[sp,#0x3c]
00007e  f7fffffe          BL       __aeabi_fmul
000082  4605              MOV      r5,r0
000084  990a              LDR      r1,[sp,#0x28]
000086  9810              LDR      r0,[sp,#0x40]
000088  f7fffffe          BL       __aeabi_fmul
00008c  4606              MOV      r6,r0
00008e  4629              MOV      r1,r5
000090  f7fffffe          BL       __aeabi_fsub
000094  4604              MOV      r4,r0
;;;93       ErrY = (AccZ*V.x - AccX*V.z);
000096  990a              LDR      r1,[sp,#0x28]
000098  9811              LDR      r0,[sp,#0x44]
00009a  f7fffffe          BL       __aeabi_fmul
00009e  4605              MOV      r5,r0
0000a0  9908              LDR      r1,[sp,#0x20]
0000a2  980f              LDR      r0,[sp,#0x3c]
0000a4  f7fffffe          BL       __aeabi_fmul
0000a8  4606              MOV      r6,r0
0000aa  4629              MOV      r1,r5
0000ac  f7fffffe          BL       __aeabi_fsub
0000b0  4681              MOV      r9,r0
;;;94       ErrZ = (AccX*V.y - AccY*V.x);
0000b2  9908              LDR      r1,[sp,#0x20]
0000b4  9810              LDR      r0,[sp,#0x40]
0000b6  f7fffffe          BL       __aeabi_fmul
0000ba  4605              MOV      r5,r0
0000bc  9909              LDR      r1,[sp,#0x24]
0000be  9811              LDR      r0,[sp,#0x44]
0000c0  f7fffffe          BL       __aeabi_fmul
0000c4  4606              MOV      r6,r0
0000c6  4629              MOV      r1,r5
0000c8  f7fffffe          BL       __aeabi_fsub
0000cc  4682              MOV      r10,r0
;;;95      	
;;;96       exInt = exInt + ErrX * KiDef;   //误差积分
0000ce  495f              LDR      r1,|L1.588|
0000d0  4620              MOV      r0,r4
0000d2  f7fffffe          BL       __aeabi_fmul
0000d6  4605              MOV      r5,r0
0000d8  485d              LDR      r0,|L1.592|
0000da  6801              LDR      r1,[r0,#0]  ; exInt
0000dc  4628              MOV      r0,r5
0000de  f7fffffe          BL       __aeabi_fadd
0000e2  495b              LDR      r1,|L1.592|
0000e4  6008              STR      r0,[r1,#0]  ; exInt
;;;97       eyInt = eyInt + ErrY * KiDef;
0000e6  4959              LDR      r1,|L1.588|
0000e8  4648              MOV      r0,r9
0000ea  f7fffffe          BL       __aeabi_fmul
0000ee  4605              MOV      r5,r0
0000f0  4858              LDR      r0,|L1.596|
0000f2  6801              LDR      r1,[r0,#0]  ; eyInt
0000f4  4628              MOV      r0,r5
0000f6  f7fffffe          BL       __aeabi_fadd
0000fa  4956              LDR      r1,|L1.596|
0000fc  6008              STR      r0,[r1,#0]  ; eyInt
;;;98       ezInt = ezInt + ErrZ * KiDef;
0000fe  4953              LDR      r1,|L1.588|
000100  4650              MOV      r0,r10
000102  f7fffffe          BL       __aeabi_fmul
000106  4605              MOV      r5,r0
000108  4853              LDR      r0,|L1.600|
00010a  6801              LDR      r1,[r0,#0]  ; ezInt
00010c  4628              MOV      r0,r5
00010e  f7fffffe          BL       __aeabi_fadd
000112  4951              LDR      r1,|L1.600|
000114  6008              STR      r0,[r1,#0]  ; ezInt
;;;99       //用叉积误差来做PI补偿修正陀螺
;;;100      GyrX = Rad(sensor.gyro.averag.x) + KpDef * VariableParameter(ErrX) * ErrX  +  exInt;
000116  484e              LDR      r0,|L1.592|
000118  6800              LDR      r0,[r0,#0]  ; exInt
00011a  f7fffffe          BL       __aeabi_f2d
00011e  e9cd0104          STRD     r0,r1,[sp,#0x10]
000122  4620              MOV      r0,r4
000124  f7fffffe          BL       VariableParameter
000128  4683              MOV      r11,r0
00012a  494c              LDR      r1,|L1.604|
00012c  f7fffffe          BL       __aeabi_fmul
000130  4680              MOV      r8,r0
000132  4621              MOV      r1,r4
000134  f7fffffe          BL       __aeabi_fmul
000138  4607              MOV      r7,r0
00013a  f7fffffe          BL       __aeabi_f2d
00013e  4605              MOV      r5,r0
000140  460e              MOV      r6,r1
000142  4940              LDR      r1,|L1.580|
000144  6bc8              LDR      r0,[r1,#0x3c]
000146  f7fffffe          BL       __aeabi_f2d
00014a  4607              MOV      r7,r0
00014c  f7fffffe          BL       ||Rad||
000150  462a              MOV      r2,r5
000152  4633              MOV      r3,r6
000154  e9cd0100          STRD     r0,r1,[sp,#0]
000158  f7fffffe          BL       __aeabi_dadd
00015c  e9cd0102          STRD     r0,r1,[sp,#8]
000160  e9dd2304          LDRD     r2,r3,[sp,#0x10]
000164  f7fffffe          BL       __aeabi_dadd
000168  e9cd0106          STRD     r0,r1,[sp,#0x18]
00016c  f7fffffe          BL       __aeabi_d2f
000170  900e              STR      r0,[sp,#0x38]
;;;101      GyrY = Rad(sensor.gyro.averag.y) + KpDef * VariableParameter(ErrY) * ErrY  +  eyInt;
000172  4838              LDR      r0,|L1.596|
000174  6800              LDR      r0,[r0,#0]  ; eyInt
000176  f7fffffe          BL       __aeabi_f2d
00017a  e9cd0104          STRD     r0,r1,[sp,#0x10]
00017e  4648              MOV      r0,r9
000180  f7fffffe          BL       VariableParameter
000184  4683              MOV      r11,r0
000186  4935              LDR      r1,|L1.604|
000188  f7fffffe          BL       __aeabi_fmul
00018c  4606              MOV      r6,r0
00018e  4649              MOV      r1,r9
000190  f7fffffe          BL       __aeabi_fmul
000194  4605              MOV      r5,r0
000196  f7fffffe          BL       __aeabi_f2d
00019a  4607              MOV      r7,r0
00019c  4688              MOV      r8,r1
00019e  4929              LDR      r1,|L1.580|
0001a0  6c08              LDR      r0,[r1,#0x40]
0001a2  f7fffffe          BL       __aeabi_f2d
0001a6  4605              MOV      r5,r0
0001a8  f7fffffe          BL       ||Rad||
0001ac  463a              MOV      r2,r7
0001ae  4643              MOV      r3,r8
0001b0  e9cd0100          STRD     r0,r1,[sp,#0]
0001b4  f7fffffe          BL       __aeabi_dadd
0001b8  e9cd0102          STRD     r0,r1,[sp,#8]
0001bc  e9dd2304          LDRD     r2,r3,[sp,#0x10]
0001c0  f7fffffe          BL       __aeabi_dadd
0001c4  e9cd0106          STRD     r0,r1,[sp,#0x18]
0001c8  f7fffffe          BL       __aeabi_d2f
0001cc  900d              STR      r0,[sp,#0x34]
;;;102      GyrZ = Rad(sensor.gyro.averag.z) + KpDef * VariableParameter(ErrZ) * ErrZ  +  ezInt;
0001ce  4822              LDR      r0,|L1.600|
0001d0  6800              LDR      r0,[r0,#0]  ; ezInt
0001d2  f7fffffe          BL       __aeabi_f2d
0001d6  e9cd0104          STRD     r0,r1,[sp,#0x10]
0001da  4650              MOV      r0,r10
0001dc  f7fffffe          BL       VariableParameter
0001e0  491e              LDR      r1,|L1.604|
0001e2  9000              STR      r0,[sp,#0]
0001e4  f7fffffe          BL       __aeabi_fmul
0001e8  4651              MOV      r1,r10
0001ea  9001              STR      r0,[sp,#4]
0001ec  f7fffffe          BL       __aeabi_fmul
0001f0  4683              MOV      r11,r0
0001f2  f7fffffe          BL       __aeabi_f2d
0001f6  e9cd0102          STRD     r0,r1,[sp,#8]
0001fa  4912              LDR      r1,|L1.580|
0001fc  6c48              LDR      r0,[r1,#0x44]
0001fe  f7fffffe          BL       __aeabi_f2d
000202  e9cd0100          STRD     r0,r1,[sp,#0]
000206  f7fffffe          BL       ||Rad||
00020a  4605              MOV      r5,r0
00020c  e9dd2302          LDRD     r2,r3,[sp,#8]
000210  f7fffffe          BL       __aeabi_dadd
000214  4607              MOV      r7,r0
000216  e9dd2304          LDRD     r2,r3,[sp,#0x10]
00021a  f7fffffe          BL       __aeabi_dadd
00021e  e9cd0106          STRD     r0,r1,[sp,#0x18]
000222  f7fffffe          BL       __aeabi_d2f
000226  900c              STR      r0,[sp,#0x30]
;;;103    	
;;;104      // 一阶龙格库塔法, 更新四元数
;;;105      Quaternion_RungeKutta(&NumQ, GyrX, GyrY, GyrZ, SampleRateHalf);   //调用四元数微分方程函数
000228  480d              LDR      r0,|L1.608|
00022a  9000              STR      r0,[sp,#0]
00022c  4806              LDR      r0,|L1.584|
00022e  e9dd320c          LDRD     r3,r2,[sp,#0x30]
000232  990e              LDR      r1,[sp,#0x38]
000234  f7fffffe          BL       Quaternion_RungeKutta
;;;106    	
;;;107      // 四元数归一化
;;;108      Quaternion_Normalize(&NumQ);
000238  4803              LDR      r0,|L1.584|
00023a  f7fffffe          BL       Quaternion_Normalize
;;;109    }
00023e  b013              ADD      sp,sp,#0x4c
000240  e8bd8ff0          POP      {r4-r11,pc}
;;;110    
                          ENDP

                  |L1.580|
                          DCD      sensor
                  |L1.584|
                          DCD      NumQ
                  |L1.588|
                          DCD      0x3a03126f
                  |L1.592|
                          DCD      exInt
                  |L1.596|
                          DCD      eyInt
                  |L1.600|
                          DCD      ezInt
                  |L1.604|
                          DCD      0x3f4ccccd
                  |L1.608|
                          DCD      0x3a83126f

                          AREA ||i.AHRS_Geteuler||, CODE, READONLY, ALIGN=2

                  AHRS_Geteuler PROC
;;;119    /*====================================================================================================*/
;;;120    void AHRS_Geteuler(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;121    {
000004  b08d              SUB      sp,sp,#0x34
;;;122      fp32 sin_pitch,sin_roll,cos_roll,cos_pitch;
;;;123      //获取滤波后的数据
;;;124      AHRS_getValues();
000006  f7fffffe          BL       AHRS_getValues
;;;125    	
;;;126      //姿态解算获取四元数
;;;127      //传入参数 Quaternion NumQ = {1, 0, 0, 0}四元数初始值  
;;;128      AHRS_GetQ(&NumQ);
00000a  4892              LDR      r0,|L2.596|
00000c  f7fffffe          BL       AHRS_GetQ
;;;129    	
;;;130      //四元数转欧拉角
;;;131      //姿态解算是解算出三个欧拉角的只不过解算出的航向角不是很准确
;;;132      Quaternion_ToAngE(&NumQ, &AngE);  //传入欧拉角结构体指针  
000010  4991              LDR      r1,|L2.600|
000012  4890              LDR      r0,|L2.596|
000014  f7fffffe          BL       Quaternion_ToAngE
;;;133    	
;;;134      //计算欧拉角的三角函数值 ROLL 和 PITCH 
;;;135      sin_roll  = sin(AngE.Roll);
000018  498f              LDR      r1,|L2.600|
00001a  6848              LDR      r0,[r1,#4]  ; AngE
00001c  f7fffffe          BL       __aeabi_f2d
000020  4606              MOV      r6,r0
000022  f7fffffe          BL       ||sin||
000026  4604              MOV      r4,r0
000028  f7fffffe          BL       __aeabi_d2f
00002c  900b              STR      r0,[sp,#0x2c]
;;;136      sin_pitch = sin(AngE.Pitch);
00002e  498a              LDR      r1,|L2.600|
000030  6808              LDR      r0,[r1,#0]  ; AngE
000032  f7fffffe          BL       __aeabi_f2d
000036  4606              MOV      r6,r0
000038  f7fffffe          BL       ||sin||
00003c  4604              MOV      r4,r0
00003e  f7fffffe          BL       __aeabi_d2f
000042  900c              STR      r0,[sp,#0x30]
;;;137      cos_roll  = cos(AngE.Roll);
000044  4984              LDR      r1,|L2.600|
000046  6848              LDR      r0,[r1,#4]  ; AngE
000048  f7fffffe          BL       __aeabi_f2d
00004c  4606              MOV      r6,r0
00004e  f7fffffe          BL       ||cos||
000052  4604              MOV      r4,r0
000054  f7fffffe          BL       __aeabi_d2f
000058  900a              STR      r0,[sp,#0x28]
;;;138      cos_pitch = cos(AngE.Pitch);
00005a  497f              LDR      r1,|L2.600|
00005c  6808              LDR      r0,[r1,#0]  ; AngE
00005e  f7fffffe          BL       __aeabi_f2d
000062  4606              MOV      r6,r0
000064  f7fffffe          BL       ||cos||
000068  4604              MOV      r4,r0
00006a  f7fffffe          BL       __aeabi_d2f
00006e  9009              STR      r0,[sp,#0x24]
;;;139        //姿态解算并不能准确解算偏航
;;;140    	//如果地磁正常时  
;;;141        //否则 就按四元数转化来的航向角为准
;;;142    	if(!flag.MagIssue && flag.MagExist){     //此处的标志位
000070  487a              LDR      r0,|L2.604|
000072  78c0              LDRB     r0,[r0,#3]  ; flag
000074  2800              CMP      r0,#0
000076  d17d              BNE      |L2.372|
000078  4878              LDR      r0,|L2.604|
00007a  7840              LDRB     r0,[r0,#1]  ; flag
00007c  2800              CMP      r0,#0
00007e  d079              BEQ      |L2.372|
;;;143    		// 地磁倾角补偿
;;;144    		fp32 hx = MAG[0]*cos_pitch + MAG[1]*sin_pitch*sin_roll - MAG[2]*cos_roll*sin_pitch; 
000080  4977              LDR      r1,|L2.608|
000082  f9b10004          LDRSH    r0,[r1,#4]  ; MAG
000086  f7fffffe          BL       __aeabi_i2f
00008a  4607              MOV      r7,r0
00008c  990a              LDR      r1,[sp,#0x28]
00008e  f7fffffe          BL       __aeabi_fmul
000092  4606              MOV      r6,r0
000094  990c              LDR      r1,[sp,#0x30]
000096  f7fffffe          BL       __aeabi_fmul
00009a  4604              MOV      r4,r0
00009c  4970              LDR      r1,|L2.608|
00009e  f9b10002          LDRSH    r0,[r1,#2]  ; MAG
0000a2  f7fffffe          BL       __aeabi_i2f
0000a6  4681              MOV      r9,r0
0000a8  990c              LDR      r1,[sp,#0x30]
0000aa  f7fffffe          BL       __aeabi_fmul
0000ae  4680              MOV      r8,r0
0000b0  990b              LDR      r1,[sp,#0x2c]
0000b2  f7fffffe          BL       __aeabi_fmul
0000b6  4606              MOV      r6,r0
0000b8  4969              LDR      r1,|L2.608|
0000ba  f9b10000          LDRSH    r0,[r1,#0]  ; MAG
0000be  f7fffffe          BL       __aeabi_i2f
0000c2  4680              MOV      r8,r0
0000c4  9909              LDR      r1,[sp,#0x24]
0000c6  f7fffffe          BL       __aeabi_fmul
0000ca  4607              MOV      r7,r0
0000cc  4631              MOV      r1,r6
0000ce  f7fffffe          BL       __aeabi_fadd
0000d2  4605              MOV      r5,r0
0000d4  4621              MOV      r1,r4
0000d6  f7fffffe          BL       __aeabi_fsub
0000da  9008              STR      r0,[sp,#0x20]
;;;145    		fp32 hy = MAG[1]*cos_roll + MAG[2]*sin_roll;
0000dc  4960              LDR      r1,|L2.608|
0000de  f9b10004          LDRSH    r0,[r1,#4]  ; MAG
0000e2  f7fffffe          BL       __aeabi_i2f
0000e6  4606              MOV      r6,r0
0000e8  990b              LDR      r1,[sp,#0x2c]
0000ea  f7fffffe          BL       __aeabi_fmul
0000ee  4604              MOV      r4,r0
0000f0  495b              LDR      r1,|L2.608|
0000f2  f9b10002          LDRSH    r0,[r1,#2]  ; MAG
0000f6  f7fffffe          BL       __aeabi_i2f
0000fa  4606              MOV      r6,r0
0000fc  990a              LDR      r1,[sp,#0x28]
0000fe  f7fffffe          BL       __aeabi_fmul
000102  4605              MOV      r5,r0
000104  4621              MOV      r1,r4
000106  f7fffffe          BL       __aeabi_fadd
00010a  9007              STR      r0,[sp,#0x1c]
;;;146    		
;;;147    		// 【利用地磁解算航向角】
;;;148    		fp32 mag_yaw = -Degree(atan2((fp64)hy,(fp64)hx));
00010c  9808              LDR      r0,[sp,#0x20]
00010e  f7fffffe          BL       __aeabi_f2d
000112  4682              MOV      r10,r0
000114  468b              MOV      r11,r1
000116  9807              LDR      r0,[sp,#0x1c]
000118  f7fffffe          BL       __aeabi_f2d
00011c  4680              MOV      r8,r0
00011e  4652              MOV      r2,r10
000120  465b              MOV      r3,r11
000122  f7fffffe          BL       atan2
000126  4606              MOV      r6,r0
000128  f7fffffe          BL       Degree
00012c  f0814100          EOR      r1,r1,#0x80000000
000130  4604              MOV      r4,r0
000132  f7fffffe          BL       __aeabi_d2f
000136  9006              STR      r0,[sp,#0x18]
;;;149    		 
;;;150    		// 【陀螺仪积分解算航向角】
;;;151    		AngE.Yaw += Degree(sensor.gyro.averag.z * Gyro_Gr * 2 * SampleRateHalf);
000138  494a              LDR      r1,|L2.612|
00013a  6c48              LDR      r0,[r1,#0x44]
00013c  f7fffffe          BL       __aeabi_f2d
000140  4606              MOV      r6,r0
000142  4a49              LDR      r2,|L2.616|
000144  4b49              LDR      r3,|L2.620|
000146  f7fffffe          BL       __aeabi_dmul
00014a  4680              MOV      r8,r0
00014c  2200              MOVS     r2,#0
00014e  f04f4380          MOV      r3,#0x40000000
000152  f7fffffe          BL       __aeabi_dmul
000156  f04f4260          MOV      r2,#0xe0000000
00015a  4b45              LDR      r3,|L2.624|
00015c  e9cd0100          STRD     r0,r1,[sp,#0]
000160  f7fffffe          BL       __aeabi_dmul
000164  4682              MOV      r10,r0
000166  f7fffffe          BL       Degree
00016a  e9cd0102          STRD     r0,r1,[sp,#8]
00016e  493a              LDR      r1,|L2.600|
000170  6888              LDR      r0,[r1,#8]  ; AngE
000172  e000              B        |L2.374|
                  |L2.372|
000174  e047              B        |L2.518|
                  |L2.374|
000176  f7fffffe          BL       __aeabi_f2d
00017a  4604              MOV      r4,r0
00017c  e9dd2302          LDRD     r2,r3,[sp,#8]
000180  f7fffffe          BL       __aeabi_dadd
000184  e9cd0104          STRD     r0,r1,[sp,#0x10]
000188  f7fffffe          BL       __aeabi_d2f
00018c  4932              LDR      r1,|L2.600|
00018e  6088              STR      r0,[r1,#8]  ; AngE
;;;152    		
;;;153    		// 【地磁解算的航向角与陀螺仪积分解算的航向角进行互补融合】
;;;154    		if((mag_yaw>90 && AngE.Yaw<-90) || (mag_yaw<-90 && AngE.Yaw>90)) 
000190  4938              LDR      r1,|L2.628|
000192  9806              LDR      r0,[sp,#0x18]
000194  f7fffffe          BL       __aeabi_cfrcmple
000198  d205              BCS      |L2.422|
00019a  492f              LDR      r1,|L2.600|
00019c  6888              LDR      r0,[r1,#8]  ; AngE
00019e  4936              LDR      r1,|L2.632|
0001a0  f7fffffe          BL       __aeabi_cfcmple
0001a4  d30a              BCC      |L2.444|
                  |L2.422|
0001a6  4934              LDR      r1,|L2.632|
0001a8  9806              LDR      r0,[sp,#0x18]
0001aa  f7fffffe          BL       __aeabi_cfcmple
0001ae  d219              BCS      |L2.484|
0001b0  4929              LDR      r1,|L2.600|
0001b2  6888              LDR      r0,[r1,#8]  ; AngE
0001b4  492f              LDR      r1,|L2.628|
0001b6  f7fffffe          BL       __aeabi_cfrcmple
0001ba  d213              BCS      |L2.484|
                  |L2.444|
;;;155    			AngE.Yaw = -AngE.Yaw * 0.998f + mag_yaw * 0.002f;
0001bc  492f              LDR      r1,|L2.636|
0001be  9806              LDR      r0,[sp,#0x18]
0001c0  f7fffffe          BL       __aeabi_fmul
0001c4  4606              MOV      r6,r0
0001c6  4824              LDR      r0,|L2.600|
0001c8  6880              LDR      r0,[r0,#8]  ; AngE
0001ca  f0804500          EOR      r5,r0,#0x80000000
0001ce  492c              LDR      r1,|L2.640|
0001d0  4628              MOV      r0,r5
0001d2  f7fffffe          BL       __aeabi_fmul
0001d6  4604              MOV      r4,r0
0001d8  4631              MOV      r1,r6
0001da  f7fffffe          BL       __aeabi_fadd
0001de  491e              LDR      r1,|L2.600|
0001e0  6088              STR      r0,[r1,#8]  ; AngE
0001e2  e00f              B        |L2.516|
                  |L2.484|
;;;156    		else AngE.Yaw = AngE.Yaw * 0.998f + mag_yaw * 0.002f;  //互补融合
0001e4  4925              LDR      r1,|L2.636|
0001e6  9806              LDR      r0,[sp,#0x18]
0001e8  f7fffffe          BL       __aeabi_fmul
0001ec  4604              MOV      r4,r0
0001ee  491a              LDR      r1,|L2.600|
0001f0  6888              LDR      r0,[r1,#8]  ; AngE
0001f2  4923              LDR      r1,|L2.640|
0001f4  f7fffffe          BL       __aeabi_fmul
0001f8  4605              MOV      r5,r0
0001fa  4621              MOV      r1,r4
0001fc  f7fffffe          BL       __aeabi_fadd
000200  4915              LDR      r1,|L2.600|
000202  6088              STR      r0,[r1,#8]  ; AngE
                  |L2.516|
;;;157    	}
000204  e00b              B        |L2.542|
                  |L2.518|
;;;158    	else 
;;;159            //【弧度转化为角度】
;;;160    		AngE.Yaw = Degree(AngE.Yaw);     // 姿态解算出的三个姿态角  【AngE.Pitch】【此值是在多大的范围之内】
000206  4914              LDR      r1,|L2.600|
000208  6888              LDR      r0,[r1,#8]  ; AngE
00020a  f7fffffe          BL       __aeabi_f2d
00020e  4606              MOV      r6,r0
000210  f7fffffe          BL       Degree
000214  4604              MOV      r4,r0
000216  f7fffffe          BL       __aeabi_d2f
00021a  490f              LDR      r1,|L2.600|
00021c  6088              STR      r0,[r1,#8]  ; AngE
                  |L2.542|
;;;161    	                                     //                       【AngE.Roll 】【此处数值为度0-360     】
;;;162            AngE.Roll = Degree(AngE.Roll);   // roll                  【AngE.Yaw  】
00021e  490e              LDR      r1,|L2.600|
000220  6848              LDR      r0,[r1,#4]  ; AngE
000222  f7fffffe          BL       __aeabi_f2d
000226  4606              MOV      r6,r0
000228  f7fffffe          BL       Degree
00022c  4604              MOV      r4,r0
00022e  f7fffffe          BL       __aeabi_d2f
000232  4909              LDR      r1,|L2.600|
000234  6048              STR      r0,[r1,#4]  ; AngE
;;;163    	    AngE.Pitch = Degree(AngE.Pitch); // pitch 
000236  6808              LDR      r0,[r1,#0]  ; AngE
000238  f7fffffe          BL       __aeabi_f2d
00023c  4606              MOV      r6,r0
00023e  f7fffffe          BL       Degree
000242  4604              MOV      r4,r0
000244  f7fffffe          BL       __aeabi_d2f
000248  4903              LDR      r1,|L2.600|
00024a  6008              STR      r0,[r1,#0]  ; AngE
;;;164    }
00024c  b00d              ADD      sp,sp,#0x34
00024e  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

000252  0000              DCW      0x0000
                  |L2.596|
                          DCD      NumQ
                  |L2.600|
                          DCD      AngE
                  |L2.604|
                          DCD      flag
                  |L2.608|
                          DCD      MAG
                  |L2.612|
                          DCD      sensor
                  |L2.616|
                          DCD      0xa09d99d9
                  |L2.620|
                          DCD      0x3f41c7a8
                  |L2.624|
                          DCD      0x3f50624d
                  |L2.628|
                          DCD      0x42b40000
                  |L2.632|
                          DCD      0xc2b40000
                  |L2.636|
                          DCD      0x3b03126f
                  |L2.640|
                          DCD      0x3f7f7cee

                          AREA ||i.AHRS_getValues||, CODE, READONLY, ALIGN=2

                  AHRS_getValues PROC
;;;44     //*******************************************【获取传感器滤波后的数据】*********************************************
;;;45     void AHRS_getValues(void)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;46     {
;;;47     	static float x,y,z;
;;;48     	
;;;49     	MPU6050_Dataanl();    //【读取6050数据减零偏  】
000004  f7fffffe          BL       MPU6050_Dataanl
;;;50     	
;;;51     	HMC5883lRead(MAG);    //【读取磁力计数据减零偏】
000008  484d              LDR      r0,|L3.320|
00000a  f7fffffe          BL       HMC5883lRead
;;;52     	
;;;53     	// 【加速度计IIR滤波】
;;;54     	sensor.acc.averag.x = IIR_I_Filter(sensor.acc.origin.x, InPut_IIR[0], OutPut_IIR[0], b_IIR, IIR_ORDER+1, a_IIR, IIR_ORDER+1);
00000e  494d              LDR      r1,|L3.324|
000010  f9b10000          LDRSH    r0,[r1,#0]  ; sensor
000014  f7fffffe          BL       __aeabi_i2d
000018  4606              MOV      r6,r0
00001a  460f              MOV      r7,r1
00001c  2005              MOVS     r0,#5
00001e  494a              LDR      r1,|L3.328|
000020  4b4a              LDR      r3,|L3.332|
000022  e9cd3000          STRD     r3,r0,[sp,#0]
000026  4b4a              LDR      r3,|L3.336|
000028  4a4a              LDR      r2,|L3.340|
00002a  e9cd1002          STRD     r1,r0,[sp,#8]
00002e  4630              MOV      r0,r6
000030  4639              MOV      r1,r7
000032  f7fffffe          BL       IIR_I_Filter
000036  4604              MOV      r4,r0
000038  f7fffffe          BL       __aeabi_d2f
00003c  4941              LDR      r1,|L3.324|
00003e  6088              STR      r0,[r1,#8]  ; sensor
;;;55     	sensor.acc.averag.y = IIR_I_Filter(sensor.acc.origin.y, InPut_IIR[1], OutPut_IIR[1], b_IIR, IIR_ORDER+1, a_IIR, IIR_ORDER+1);
000040  f9b10002          LDRSH    r0,[r1,#2]  ; sensor
000044  f7fffffe          BL       __aeabi_i2d
000048  4606              MOV      r6,r0
00004a  460f              MOV      r7,r1
00004c  2005              MOVS     r0,#5
00004e  493e              LDR      r1,|L3.328|
000050  4b3e              LDR      r3,|L3.332|
000052  e9cd3000          STRD     r3,r0,[sp,#0]
000056  4b3e              LDR      r3,|L3.336|
000058  3328              ADDS     r3,r3,#0x28
00005a  4a3e              LDR      r2,|L3.340|
00005c  3228              ADDS     r2,r2,#0x28
00005e  e9cd1002          STRD     r1,r0,[sp,#8]
000062  4630              MOV      r0,r6
000064  4639              MOV      r1,r7
000066  f7fffffe          BL       IIR_I_Filter
00006a  4604              MOV      r4,r0
00006c  f7fffffe          BL       __aeabi_d2f
000070  4934              LDR      r1,|L3.324|
000072  60c8              STR      r0,[r1,#0xc]
;;;56     	sensor.acc.averag.z = IIR_I_Filter(sensor.acc.origin.z, InPut_IIR[2], OutPut_IIR[2], b_IIR, IIR_ORDER+1, a_IIR, IIR_ORDER+1);
000074  f9b10004          LDRSH    r0,[r1,#4]  ; sensor
000078  f7fffffe          BL       __aeabi_i2d
00007c  4606              MOV      r6,r0
00007e  460f              MOV      r7,r1
000080  2005              MOVS     r0,#5
000082  4931              LDR      r1,|L3.328|
000084  4b31              LDR      r3,|L3.332|
000086  e9cd3000          STRD     r3,r0,[sp,#0]
00008a  4b31              LDR      r3,|L3.336|
00008c  3350              ADDS     r3,r3,#0x50
00008e  4a31              LDR      r2,|L3.340|
000090  3250              ADDS     r2,r2,#0x50
000092  e9cd1002          STRD     r1,r0,[sp,#8]
000096  4630              MOV      r0,r6
000098  4639              MOV      r1,r7
00009a  f7fffffe          BL       IIR_I_Filter
00009e  4604              MOV      r4,r0
0000a0  f7fffffe          BL       __aeabi_d2f
0000a4  4927              LDR      r1,|L3.324|
0000a6  6108              STR      r0,[r1,#0x10]
;;;57     	
;;;58     	// 【陀螺仪一阶低通滤波】
;;;59      	sensor.gyro.averag.x = LPF_1st(x,sensor.gyro.radian.x * Gyro_G,0.386f);	x = sensor.gyro.averag.x;
0000a8  6dc8              LDR      r0,[r1,#0x5c]
0000aa  f7fffffe          BL       __aeabi_f2d
0000ae  4607              MOV      r7,r0
0000b0  4a29              LDR      r2,|L3.344|
0000b2  4b2a              LDR      r3,|L3.348|
0000b4  f7fffffe          BL       __aeabi_dmul
0000b8  4605              MOV      r5,r0
0000ba  f7fffffe          BL       __aeabi_d2f
0000be  4604              MOV      r4,r0
0000c0  4a27              LDR      r2,|L3.352|
0000c2  4621              MOV      r1,r4
0000c4  4827              LDR      r0,|L3.356|
0000c6  6800              LDR      r0,[r0,#0]  ; x
0000c8  f7fffffe          BL       LPF_1st
0000cc  491d              LDR      r1,|L3.324|
0000ce  63c8              STR      r0,[r1,#0x3c]
0000d0  4608              MOV      r0,r1
0000d2  6bc0              LDR      r0,[r0,#0x3c]
0000d4  4923              LDR      r1,|L3.356|
0000d6  6008              STR      r0,[r1,#0]  ; x
;;;60      	sensor.gyro.averag.y = LPF_1st(y,sensor.gyro.radian.y * Gyro_G,0.386f);	y = sensor.gyro.averag.y;
0000d8  491a              LDR      r1,|L3.324|
0000da  6e08              LDR      r0,[r1,#0x60]
0000dc  f7fffffe          BL       __aeabi_f2d
0000e0  4607              MOV      r7,r0
0000e2  4a1d              LDR      r2,|L3.344|
0000e4  4b1d              LDR      r3,|L3.348|
0000e6  f7fffffe          BL       __aeabi_dmul
0000ea  4605              MOV      r5,r0
0000ec  f7fffffe          BL       __aeabi_d2f
0000f0  4604              MOV      r4,r0
0000f2  4a1b              LDR      r2,|L3.352|
0000f4  4621              MOV      r1,r4
0000f6  481c              LDR      r0,|L3.360|
0000f8  6800              LDR      r0,[r0,#0]  ; y
0000fa  f7fffffe          BL       LPF_1st
0000fe  4601              MOV      r1,r0
000100  4810              LDR      r0,|L3.324|
000102  6401              STR      r1,[r0,#0x40]
000104  6c00              LDR      r0,[r0,#0x40]
000106  4918              LDR      r1,|L3.360|
000108  6008              STR      r0,[r1,#0]  ; y
;;;61      	sensor.gyro.averag.z = LPF_1st(z,sensor.gyro.radian.z * Gyro_G,0.386f);	z = sensor.gyro.averag.z;
00010a  490e              LDR      r1,|L3.324|
00010c  6e48              LDR      r0,[r1,#0x64]
00010e  f7fffffe          BL       __aeabi_f2d
000112  4607              MOV      r7,r0
000114  4a10              LDR      r2,|L3.344|
000116  4b11              LDR      r3,|L3.348|
000118  f7fffffe          BL       __aeabi_dmul
00011c  4605              MOV      r5,r0
00011e  f7fffffe          BL       __aeabi_d2f
000122  4604              MOV      r4,r0
000124  4a0e              LDR      r2,|L3.352|
000126  4621              MOV      r1,r4
000128  4810              LDR      r0,|L3.364|
00012a  6800              LDR      r0,[r0,#0]  ; z
00012c  f7fffffe          BL       LPF_1st
000130  4601              MOV      r1,r0
000132  4804              LDR      r0,|L3.324|
000134  6441              STR      r1,[r0,#0x44]
000136  6c40              LDR      r0,[r0,#0x44]
000138  490c              LDR      r1,|L3.364|
00013a  6008              STR      r0,[r1,#0]  ; z
;;;62     }
00013c  e8bd81ff          POP      {r0-r8,pc}
;;;63     
                          ENDP

                  |L3.320|
                          DCD      MAG
                  |L3.324|
                          DCD      sensor
                  |L3.328|
                          DCD      a_IIR
                  |L3.332|
                          DCD      b_IIR
                  |L3.336|
                          DCD      OutPut_IIR
                  |L3.340|
                          DCD      InPut_IIR
                  |L3.344|
                          DCD      0xc89d6830
                  |L3.348|
                          DCD      0x3f9f3ffe
                  |L3.352|
                          DCD      0x3ec5a1cb
                  |L3.356|
                          DCD      x
                  |L3.360|
                          DCD      y
                  |L3.364|
                          DCD      z

                          AREA ||.bss||, DATA, NOINIT, ALIGN=3

                  InPut_IIR
                          %        120
                  OutPut_IIR
                          %        120
                  AngE
                          %        12

                          AREA ||.data||, DATA, ALIGN=3

                  b_IIR
000000  e0000000          DCFD     0x3f4a36e2e0000000 ; 0.00079999997979030013
000004  3f4a36e2
000008  e0000000          DCFD     0x3f6a36e2e0000000 ; 0.0031999999191612005
00000c  3f6a36e2
000010  40000000          DCFD     0x3f73a92a40000000 ; 0.0048000002279877663
000014  3f73a92a
000018  e0000000          DCFD     0x3f6a36e2e0000000 ; 0.0031999999191612005
00001c  3f6a36e2
000020  e0000000          DCFD     0x3f4a36e2e0000000 ; 0.00079999997979030013
000024  3f4a36e2
                  a_IIR
000028  00000000          DCFD     0x3ff0000000000000 ; 1
00002c  3ff00000
000030  80000000          DCFD     0xc008240b80000000 ; -3.0176000595092773
000034  c008240b
000038  e0000000          DCFD     0x400c0ebee0000000 ; 3.5072000026702881
00003c  400c0ebe
000040  00000000          DCFD     0xbffd8fc500000000 ; -1.847599983215332
000044  bffd8fc5
000048  e0000000          DCFD     0x3fd7bb2fe0000000 ; 0.37079998850822449
00004c  3fd7bb2f
                  NumQ
000050  3f800000          DCFS     0x3f800000 ; 1
000054  00000000          DCFS     0x00000000 ; 0
000058  00000000          DCFS     0x00000000 ; 0
00005c  00000000          DCFS     0x00000000 ; 0
                  MAG
                          DCD      0x00000000
000064  00000000          DCB      0x00,0x00,0x00,0x00
                  x
                          DCD      0x00000000
                  y
                          DCD      0x00000000
                  z
                          DCD      0x00000000
                  exInt
000074  00000000          DCFS     0x00000000 ; 0
                  eyInt
000078  00000000          DCFS     0x00000000 ; 0
                  ezInt
00007c  00000000          DCFS     0x00000000 ; 0
